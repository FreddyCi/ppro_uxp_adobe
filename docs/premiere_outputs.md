This file is a merged representation of the entire codebase, combined into a single document by Repomix.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
html/
  assets/
    HD 1080i 25.epr
  scripts/
    fix-imports.js
  src/
    appPreference.ts
    effects.ts
    eventManager.ts
    export.ts
    import.ts
    keyframe.ts
    markers.ts
    metadata.ts
    project.ts
    projectPanel.ts
    properties.ts
    sequence.ts
    sequenceEditor.ts
    settings.ts
    sourceMonitor.ts
    transition.ts
    utils.ts
  index.html
  index.ts
  manifest.json
  package.json
  tsconfig.json
  types.d.ts
.gitignore
types.d.ts
```

# Files

## File: html/assets/HD 1080i 25.epr
```
<?xml version="1.0" encoding="UTF-8"?>
<PremiereData Version="3">
	<PresetName>($$$/AME/EncoderHost/Presets/1de1c934-0075-44ca-af22-8d53815b1a95/PresetName=HD 1080i 25)</PresetName>
	<PresetComments>($$$/AME/EncoderHost/Presets/1de1c934-0075-44ca-af22-8d53815b1a95/PresetComments=High Quality HD for 1080i 25 fps sources)</PresetComments>
	<PresetUserComments></PresetUserComments>
	<PresetCreatorApp></PresetCreatorApp>
	<PresetCreatorPostProc></PresetCreatorPostProc>
	<ExporterName></ExporterName>
	<ExporterClassID>1280266825</ExporterClassID>
	<ExporterFileType>1836082994</ExporterFileType>
	<ExportParamContainer ObjectRef="1"/>
	<PresetID>c7b0d68e-a43f-4503-80e7-9f94c977445a</PresetID>
	<DoAudio>true</DoAudio>
	<DoVideo>true</DoVideo>
	<DoEmulation>false</DoEmulation>
	<FolderDisplayPath></FolderDisplayPath>
	<StandardFilters Version="1">
		<TimeInterpolationType>0</TimeInterpolationType>
		<Rotation>0.</Rotation>
		<CropState>false</CropState>
		<CropRect>0,0,0,0</CropRect>
		<CropType>0</CropType>
		<DeinterlaceState>false</DeinterlaceState>
		<UseMaximumRenderQuality>false</UseMaximumRenderQuality>
		<UsePreview>false</UsePreview>
		<UseFrameBlending>false</UseFrameBlending>
		<CustomStartTime>-101606400000000000</CustomStartTime>
		<RenderAlphaOnly>false</RenderAlphaOnly>
		<MaximumFileSize>0</MaximumFileSize>
		<UseProxiesForExport>false</UseProxiesForExport>
		<DoExportCR>false</DoExportCR>
	</StandardFilters>
	<ExportXMPOptionKey>10</ExportXMPOptionKey>
	<IngestPreset>false</IngestPreset>
	<IngestCopyEnabled>false</IngestCopyEnabled>
	<IngestCopyPath></IngestCopyPath>
	<IngestCopyVerificationType>-1</IngestCopyVerificationType>
	<IngestTranscodeEnabled>false</IngestTranscodeEnabled>
	<IngestTranscodePath></IngestTranscodePath>
	<IngestTranscodePresetName></IngestTranscodePresetName>
	<IngestTranscodeExporterModuleName></IngestTranscodeExporterModuleName>
	<IngestNamingEnabled>false</IngestNamingEnabled>
	<IngestNamingPreset></IngestNamingPreset>
	<IngestMetadataEnabled>false</IngestMetadataEnabled>
	<IngestMetadataPreset></IngestMetadataPreset>
	<IngestPresetUserComments></IngestPresetUserComments>
	<IngestAnalysisEnabled>false</IngestAnalysisEnabled>
	<DoEffects>true</DoEffects>
	<DoCaptions>true</DoCaptions>
	<DoMetadata>true</DoMetadata>
	<ExporterParamContainer ObjectID="1" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="2"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="2" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>10</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>0</ParamIdentifier>
		<ParamName></ParamName>
		<ExporterChildParams ObjectRef="3"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="3" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="4"/>
			<ParamContainerItem Index="1" ObjectRef="57"/>
			<ParamContainerItem Index="2" ObjectRef="82"/>
			<ParamContainerItem Index="3" ObjectRef="95"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="4" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoTabGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="5"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="5" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="6"/>
			<ParamContainerItem Index="1" ObjectRef="7"/>
			<ParamContainerItem Index="2" ObjectRef="10"/>
			<ParamContainerItem Index="3" ObjectRef="24"/>
			<ParamContainerItem Index="4" ObjectRef="32"/>
			<ParamContainerItem Index="5" ObjectRef="38"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="6" ClassID="d0f6b8af-8ddb-4381-acf8-3e817480d07d" Version="1">
		<ParamType>7</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoMatchSource</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="7" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEVideoCodecGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="8"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="8" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="9"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="9" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1296257108</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoCodec</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="10" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEBasicVideoGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="11"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="11" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="12"/>
			<ParamContainerItem Index="1" ObjectRef="13"/>
			<ParamContainerItem Index="2" ObjectRef="14"/>
			<ParamContainerItem Index="3" ObjectRef="15"/>
			<ParamContainerItem Index="4" ObjectRef="16"/>
			<ParamContainerItem Index="5" ObjectRef="17"/>
			<ParamContainerItem Index="6" ObjectRef="18"/>
			<ParamContainerItem Index="7" ObjectRef="19"/>
			<ParamContainerItem Index="8" ObjectRef="20"/>
			<ParamContainerItem Index="9" ObjectRef="21"/>
			<ParamContainerItem Index="10" ObjectRef="22"/>
			<ParamContainerItem Index="11" ObjectRef="23"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="12" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>75</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIsSlider>true</ParamIsSlider>
		<ParamIdentifier>ADBEVideoQuality</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="13" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1920</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoWidth</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="14" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1080</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoHeight</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="15" ClassID="8def7863-204e-4206-8791-54a78f15c66b" Version="1">
		<ParamValue>10160640000</ParamValue>
		<ParamType>4</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoFPS</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="16" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>4</ParamOrdinalValue>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEVideoPulldown</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="17" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>5</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoFieldType</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="18" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>2</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>6</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoDisplayAspect</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="19" ClassID="8d9836e8-d00a-4a00-bfc0-dfbb73540736" Version="1">
		<ParamValue>17280,17280</ParamValue>
		<ParamType>11</ParamType>
		<ParamOrdinalValue>7</ParamOrdinalValue>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEVideoAspect</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="20" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>8</ParamOrdinalValue>
		<ParamIdentifier>ADBETVStandard</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="21" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>4</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>9</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoProfile</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="22" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>4</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>10</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoMPEGProfileLevel</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="23" ClassID="d0f6b8af-8ddb-4381-acf8-3e817480d07d" Version="1">
		<ParamType>1</ParamType>
		<ParamOrdinalValue>11</ParamOrdinalValue>
		<ParamIdentifier>ADBERenderDeepColor</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="24" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoBitrateSettingsGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="25"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="25" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="26"/>
			<ParamContainerItem Index="1" ObjectRef="27"/>
			<ParamContainerItem Index="2" ObjectRef="28"/>
			<ParamContainerItem Index="3" ObjectRef="29"/>
			<ParamContainerItem Index="4" ObjectRef="30"/>
			<ParamContainerItem Index="5" ObjectRef="31"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="26" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoBitrateEncoding</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="27" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>2</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEVideoBitrateLevel</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="28" ClassID="018cf63d-c58d-4d39-97df-36b6b2d6ef88" Version="1">
		<ParamValue>15.</ParamValue>
		<ParamType>3</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIsSlider>true</ParamIsSlider>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEVideoBitrate</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="29" ClassID="018cf63d-c58d-4d39-97df-36b6b2d6ef88" Version="1">
		<ParamValue>4.</ParamValue>
		<ParamType>3</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIsSlider>true</ParamIsSlider>
		<ParamIdentifier>ADBEVideoMinBitrate</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="30" ClassID="018cf63d-c58d-4d39-97df-36b6b2d6ef88" Version="1">
		<ParamValue>15.</ParamValue>
		<ParamType>3</ParamType>
		<ParamOrdinalValue>4</ParamOrdinalValue>
		<ParamIsSlider>true</ParamIsSlider>
		<ParamIdentifier>ADBEVideoTargetBitrate</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="31" ClassID="018cf63d-c58d-4d39-97df-36b6b2d6ef88" Version="1">
		<ParamValue>18.5</ParamValue>
		<ParamType>3</ParamType>
		<ParamOrdinalValue>5</ParamOrdinalValue>
		<ParamIsSlider>true</ParamIsSlider>
		<ParamIdentifier>ADBEVideoMaxBitrate</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="32" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>4</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoGOPSettingsGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="33"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="33" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="34"/>
			<ParamContainerItem Index="1" ObjectRef="35"/>
			<ParamContainerItem Index="2" ObjectRef="36"/>
			<ParamContainerItem Index="3" ObjectRef="37"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="34" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>3</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoMFrames</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="35" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>12</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoNFrames</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="36" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoClosedGOPInterval</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="37" ClassID="d0f6b8af-8ddb-4381-acf8-3e817480d07d" Version="1">
		<ParamValue>true</ParamValue>
		<ParamType>1</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoAutoGOPPlacement</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="38" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>5</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoAdvancedSettingsGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="39"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="39" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="40"/>
			<ParamContainerItem Index="1" ObjectRef="41"/>
			<ParamContainerItem Index="2" ObjectRef="42"/>
			<ParamContainerItem Index="3" ObjectRef="43"/>
			<ParamContainerItem Index="4" ObjectRef="44"/>
			<ParamContainerItem Index="5" ObjectRef="45"/>
			<ParamContainerItem Index="6" ObjectRef="46"/>
			<ParamContainerItem Index="7" ObjectRef="47"/>
			<ParamContainerItem Index="8" ObjectRef="48"/>
			<ParamContainerItem Index="9" ObjectRef="49"/>
			<ParamContainerItem Index="10" ObjectRef="50"/>
			<ParamContainerItem Index="11" ObjectRef="51"/>
			<ParamContainerItem Index="12" ObjectRef="52"/>
			<ParamContainerItem Index="13" ObjectRef="53"/>
			<ParamContainerItem Index="14" ObjectRef="54"/>
			<ParamContainerItem Index="15" ObjectRef="55"/>
			<ParamContainerItem Index="16" ObjectRef="56"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="40" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>10</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoMacroblockQuantization</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="41" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoVBVBufferSize</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="42" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoNoiseControl</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="43" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoWriteSDE</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="44" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>4</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoVideoFormat</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="45" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1920</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>5</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoHorizontal</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="46" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1080</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>6</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoVertical</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="47" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>7</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoColorPrimaries</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="48" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>8</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoTransferChars</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="49" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>9</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoMatrixCoefficients</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="50" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>10</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoForceVBVDelay</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="51" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>11</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoIntraDCPrecision</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="52" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>12</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoWriteSeqEndCode</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="53" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>13</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoEmbedSVCDUserBlks</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="54" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>14</ParamOrdinalValue>
		<ParamIdentifier>ADBEVideoIgnoreFrameInterval</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="55" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>25</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>15</ParamOrdinalValue>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEVideoMinFramePercentage</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="56" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>16</ParamOrdinalValue>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEVideoPadFramePercentage</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="57" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioTabGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="58"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="58" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="59"/>
			<ParamContainerItem Index="1" ObjectRef="62"/>
			<ParamContainerItem Index="2" ObjectRef="71"/>
			<ParamContainerItem Index="3" ObjectRef="74"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="59" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioCodecGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="60"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="60" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="61"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="61" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1297106247</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioFormat</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="62" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIdentifier>ADBEBasicAudioGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="63"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="63" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="64"/>
			<ParamContainerItem Index="1" ObjectRef="65"/>
			<ParamContainerItem Index="2" ObjectRef="66"/>
			<ParamContainerItem Index="3" ObjectRef="67"/>
			<ParamContainerItem Index="4" ObjectRef="68"/>
			<ParamContainerItem Index="5" ObjectRef="69"/>
			<ParamContainerItem Index="6" ObjectRef="70"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="64" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1296257108</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioCodec</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="65" ClassID="d0f6b8af-8ddb-4381-acf8-3e817480d07d" Version="1">
		<ParamType>7</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEAudioCodecPrefsButton</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="66" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>48000</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioRatePerSecond</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="67" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>2</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIsHidden>true</ParamIsHidden>
		<ParamIdentifier>ADBEAudioNumChannels</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="68" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>4</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioSampleType</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="69" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>2</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>5</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioLayer</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="70" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>6</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioMode</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="71" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioBitrateSettingsGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="72"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="72" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="73"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="73" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>384</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioBitrate</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="74" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioAdvancedSettingsGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="75"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="75" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="76"/>
			<ParamContainerItem Index="1" ObjectRef="77"/>
			<ParamContainerItem Index="2" ObjectRef="78"/>
			<ParamContainerItem Index="3" ObjectRef="79"/>
			<ParamContainerItem Index="4" ObjectRef="80"/>
			<ParamContainerItem Index="5" ObjectRef="81"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="76" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>2</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioPsychMode</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="77" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioDeemphasis</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="78" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioEnableCRC</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="79" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioSetPrivateBit</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="80" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>4</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioSetCopyrightBit</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="81" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>5</ParamOrdinalValue>
		<ParamIdentifier>ADBEAudioSetOriginalBit</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="82" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEMuxTabGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="83"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="83" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="84"/>
			<ParamContainerItem Index="1" ObjectRef="87"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="84" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEBasicMuxGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="85"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="85" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="86"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="86" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEVMCMux_Type</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="87" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIdentifier>ADBEMuxDetailsGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="88"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="88" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="89"/>
			<ParamContainerItem Index="1" ObjectRef="90"/>
			<ParamContainerItem Index="2" ObjectRef="91"/>
			<ParamContainerItem Index="3" ObjectRef="92"/>
			<ParamContainerItem Index="4" ObjectRef="93"/>
			<ParamContainerItem Index="5" ObjectRef="94"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="89" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBEMuxBitrateType</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="90" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIdentifier>ADBEMuxMuxRate</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="91" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>2048</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIdentifier>ADBEMuxPacketSize</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="92" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>1</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIdentifier>ADBEMuxPacketsPerPack</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="93" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>4</ParamOrdinalValue>
		<ParamIdentifier>ADBEMuxVideoBufferSize</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="94" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>4</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>5</ParamOrdinalValue>
		<ParamIdentifier>ADBEMuxAudioBufferSize</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="95" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>8</ParamType>
		<ParamOrdinalValue>3</ParamOrdinalValue>
		<ParamIdentifier>ADBECaptionsTabGroup</ParamIdentifier>
		<ExporterChildParams ObjectRef="96"/>
	</ExporterParam>
	<ExporterParamContainer ObjectID="96" ClassID="5c20a4a5-5e7c-4032-85b8-26ad4531fe7b" Version="1">
		<ParamContainerItems Version="1">
			<ParamContainerItem Index="0" ObjectRef="97"/>
			<ParamContainerItem Index="1" ObjectRef="98"/>
			<ParamContainerItem Index="2" ObjectRef="99"/>
		</ParamContainerItems>
		<ContainedParamsVersion>1</ContainedParamsVersion>
	</ExporterParamContainer>
	<ExporterParam ObjectID="97" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>0</ParamOrdinalValue>
		<ParamIdentifier>ADBECaptionsExportOption</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="98" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamType>2</ParamType>
		<ParamOrdinalValue>1</ParamOrdinalValue>
		<ParamIsDisabled>true</ParamIsDisabled>
		<ParamIdentifier>ADBECaptionsFormat</ParamIdentifier>
	</ExporterParam>
	<ExporterParam ObjectID="99" ClassID="9f049ab7-d48f-43e9-a8ca-4d7f21233625" Version="1">
		<ParamValue>102</ParamValue>
		<ParamType>2</ParamType>
		<ParamOrdinalValue>2</ParamOrdinalValue>
		<ParamIsDisabled>true</ParamIsDisabled>
		<ParamIdentifier>ADBECaptionsFrameRate</ParamIdentifier>
	</ExporterParam>
</PremiereData>
```

## File: html/scripts/fix-imports.js
```javascript
const fs = require("fs");
const path = require("path");

const rootDir = path.resolve(__dirname, "../..");
const indexFilePath = path.resolve(rootDir, "build-html/index.js");

console.log(`Fixing imports in ${indexFilePath}`);

const content = fs.readFileSync(indexFilePath, { encoding: "utf-8" });
const newContent = content.replace(
  'Object.defineProperty(exports, "__esModule", { value: true });',
  ""
); // remove the exports property line as we have no global exports at all 
fs.writeFileSync(indexFilePath, newContent, { encoding: "utf-8" });
```

## File: html/src/appPreference.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2025 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { premierepro, Project, Sequence } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

const AUTO_PEAK_GENERATION_KEY =
  ppro.Constants.PreferenceKey.AUTO_PEAK_GENERATION;
const appPreference = ppro.AppPreference;

/**
 * Get auto peak generation preference settings
 * @return [String] Auto Peak Preference Setting
 */
export async function getPreferenceSetting() {
  return appPreference.getValue(AUTO_PEAK_GENERATION_KEY);
}

/**
 * Set auto peak generation preference settings alternatively
 * @return [Boolean] if operation succeed
 */
export async function setPreferenceSetting() {
  let succeed = true;
  try {
    let newValue = true;
    if (appPreference.getValue(AUTO_PEAK_GENERATION_KEY) == "true") {
      newValue = false;
    }

    appPreference.setValue(
      AUTO_PEAK_GENERATION_KEY,
      newValue,
      appPreference.PROPERTY_PERSISTENT
    );
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }
  return succeed;
}
```

## File: html/src/effects.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import { log } from "./utils";
import type { premierepro } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;

let matchnames;
let videoComponentChain;
let audioComponentChain;
const filterFactory = ppro.VideoFilterFactory;
const audioFilterFactory = ppro.AudioFilterFactory;

export async function getVideoComponentChain() {
  const proj = await ppro.Project.getActiveProject();
  if (!proj) {
    log("No active project", "red");
    return;
  } else {
    const sequence = await proj.getActiveSequence();
    if (!sequence) {
      log("No sequence found", "red");
      return;
    } else {
      const videoTrack = await sequence.getVideoTrack(0);
      if (!videoTrack) {
        log("No videoTrack found", "red");
        return;
      } else {
        const trackItems = await videoTrack.getTrackItems(
          ppro.Constants.TrackItemType.CLIP,
          false
        );
        if (trackItems.length === 0) {
          log("No trackItems found", "red");
          return;
        } else {
          videoComponentChain = await trackItems[0].getComponentChain();
          matchnames = await filterFactory.getMatchNames();
        }
      }
    }
  }
  return videoComponentChain;
}

async function getAudioClipTrackItem() {
  const proj = await ppro.Project.getActiveProject();
  if (!proj) {
    log("No active project", "red");
  } else {
    const sequence = await proj.getActiveSequence();
    if (!sequence) {
      log("No sequence found", "red");
    } else {
      const audioTrack = await sequence.getAudioTrack(0);
      if (!audioTrack) {
        log("No videoTrack found", "red");
      } else {
        const trackItems = await audioTrack.getTrackItems(
          ppro.Constants.TrackItemType.CLIP,
          false
        );
        if (trackItems.length === 0) {
          log("No trackItems found", "red");
        } else {
          return trackItems[0];
        }
      }
    }
  }
  return null;
}

export async function getAudioComponentChain() {
  const audioTrackItem = await getAudioClipTrackItem();
  let audioComponentChain = undefined;
  if (audioTrackItem) {
    audioComponentChain = await audioTrackItem.getComponentChain();
  }
  return audioComponentChain;
}

//Gets all the effects matchNames.
export async function getEffectsName() {
  return await filterFactory.getMatchNames();
}

export async function addEffects(project) {
  if (project) {
    const videoComponentChain = await getVideoComponentChain();
    if (!videoComponentChain) {
      return;
    }
    const newComponent = await filterFactory.createComponent(
      "PR.ADBE Gamma Correction"
    );

    let success = false;
    try {
      project.lockedAccess(() => {
        success = project.executeTransaction((compoundAction) => {
          var action1 = videoComponentChain.createInsertComponentAction(
            newComponent,
            2
          );
          compoundAction.addAction(action1);
        }, "createInsertComponentAction");
      });
    } catch (err) {
      log(`Error: ${err}`, "red");
      return false;
    }

    return success;
  } else {
    log(`No project found.`, "red");
  }
}

export async function addMultipleEffects(project) {
  if (project) {
    const videoComponentChain = await getVideoComponentChain();
    if (!videoComponentChain) {
      return;
    }
    const newComponent1 = await filterFactory.createComponent(
      "PR.ADBE Gamma Correction"
    );

    const newComponent2 = await filterFactory.createComponent(
      "PR.ADBE Extract"
    );

    let success = false;
    try {
      project.lockedAccess(() => {
        success = project.executeTransaction((compoundAction) => {
          var action1 = videoComponentChain.createInsertComponentAction(
            newComponent1,
            2
          );
          var action2 = videoComponentChain.createInsertComponentAction(
            newComponent2,
            2
          );
          compoundAction.addAction(action1);
          compoundAction.addAction(action2);
        }, "Add Multiple Effects");
      });
    } catch (err) {
      log(`Error: ${err}`, "red");
      return false;
    }
    return success;
  } else {
    log(`No project found.`, "red");
  }
}

export async function addVocalEnhancerEffect(project) {
  let audioComponentChain = await getAudioComponentChain();
  if (!audioComponentChain) {
    return false;
  }
  let success = false;
  try {
    const trackItem = await getAudioClipTrackItem();
    const newComponent = await audioFilterFactory.createComponentByDisplayName(
      "Vocal Enhancer",
      trackItem
    );
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        let action1 = audioComponentChain.createInsertComponentAction(
          newComponent,
          2
        );
        compoundAction.addAction(action1);
      }, "createInsertComponentAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
  }
  return success;
}

export async function removeEffects(project) {
  if (project) {
    const videoComponentChain = await getVideoComponentChain();
    if (!videoComponentChain) {
      return;
    }
    let newComponentToBeDeleted;
    let success;
    try {
      await project.lockedAccess(() => {
        const initialComponenetCount = videoComponentChain.getComponentCount();
        if (initialComponenetCount < 3) {
          log("There is no effects to be removed");
        }
        newComponentToBeDeleted = videoComponentChain.getComponentAtIndex(2);

        success = project.executeTransaction(
          (compoundAction) => {
            var action1 = videoComponentChain.createRemoveComponentAction(
              newComponentToBeDeleted
            );
            compoundAction.addAction(action1);
          },
          "createRemoveComponentAction",
          "createRemoveComponentAction"
        );
      });
    } catch (err) {
      log(`Error: ${err}`, "red");
      return false;
    }

    return success;
  } else {
    log(`No project found.`, "red");
  }
}
```

## File: html/src/eventManager.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type {
  AudioClipTrackItem,
  premierepro,
  VideoClipTrackItem,
} from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";
import { getActiveProject, getActiveSequence } from "./project";
import {
  addProjectItemsOptions,
  clearProjectItemOptions,
  refreshProjectItemOptions,
} from "./sourceMonitor";

/**
 * callback function for sequence close event
 * console sequence name closed and update active sequence name in case of no active seq
 */
async function sequenceClosed(sequence) {
  log("Sequence Closed: " + sequence.name);
  // check for case that no more active sequence exist
  const project = await getActiveProject();
  sequence = await getActiveSequence(project);
  if (!sequence) {
    document.getElementById("active-sequence-name").innerText =
      "No Active Sequence";
  }
}

/**
 * callback function for project open event
 * console project name opened
 */
async function onProjectOpened() {
  const project = await getActiveProject();
  log("Project Opened: " + project.name);
}

/**
 * callback function for project close event
 * console project name closed
 */
async function projectClosed(project) {
  log("Project Closed: " + project.name);
  clearProjectItemOptions();
}

/**
 * callback function for sequence activated event
 * add sequence close event listener and update active seq name
 */
async function onSequenceActivated(sequence) {
  // add close event listener for the current active sequence
  const project = await getActiveProject();
  const seq = await getActiveSequence(project);
  ppro.EventManager.addEventListener(
    seq,
    ppro.Constants.SequenceEvent.CLOSED,
    sequenceClosed,
    false
  );
  // update active sequence name
  document.getElementById("active-sequence-name").innerText = sequence.name;
}

/**
 * callback function for project activated event
 * add project close event listener and update active project name
 */
async function onProjectActivated(project) {
  // refresh current projectItem options
  await refreshProjectItemOptions();
  ppro.EventManager.addGlobalEventListener(
    ppro.Constants.ProjectEvent.CLOSED,
    projectClosed
  );
  // update active project name
  document.getElementById("active-project-name").innerText = project.name;
}

/**
 * callback function for project dirty event
 * Update projectItem options when user remove/add new projectItem
 */
async function onProjectDirty() {
  await refreshProjectItemOptions();
}

/**
 * Callback function for sequence trackItem selection change event
 * Log selected trackItem's name in console
 */
async function onSequenceSelectionChange(sequence) {
  console.log(`Selection for ${sequence.name} changed`);
  const project = await getActiveProject();
  const seq = await getActiveSequence(project);
  const selection = await seq.getSelection();
  const trackItems = await selection.getTrackItems();
  trackItems.forEach(async (item: VideoClipTrackItem | AudioClipTrackItem) => {
    let name = await item.getName();
    console.log(`selection for trackItem named ${name} changed`);
  });
}

/**
 * Callback function for encoder complete event
 * Log encoder complete in console when AME job complete
 */
async function onEncoderComplete() {
  console.log("Encoder process complete");
}

/**
 * Callback function for encoder cancel event
 * Log encoder in progress in console when AME job is in progress
 */
async function onEncoderProgress() {
  console.log("Encoder in progress");
}

/**
 * Add Encoder event listeners
 */
export async function addEncoderListeners() {
  let encoder = await ppro.EncoderManager.getManager();
  await ppro.EventManager.addEventListener(
    encoder,
    ppro.EncoderManager.EVENT_RENDER_PROGRESS,
    onEncoderProgress
  );
  await ppro.EventManager.addEventListener(
    encoder,
    ppro.EncoderManager.EVENT_RENDER_COMPLETE,
    onEncoderComplete
  );
}

/**
 * Callback function for effect drop event
 * Log Effect dropped when new effect is dropped to trackItem
 */
export async function onEffectDropped() {
  console.log("Effect dropped");
}

/**
 * Callback function for snap trackItem event
 * Log trackItem snapped when trackItem is snapped in timeline
 */
async function onSnapTrackItem() {
  console.log("TrackItem snapped");
}

/**
 * Add project and sequence event listeners
 */
export async function addProjSeqListeners() {
  // intialize active project and active sequence name, if any
  const project = await getActiveProject();
  if (project) {
    document.getElementById("active-project-name").innerText = project.name;
  }
  const sequence = await getActiveSequence(project);
  if (sequence) {
    document.getElementById("active-sequence-name").innerText = sequence.name;
  }

  // load projectItems for source monitor
  await addProjectItemsOptions();

  // add project event listener
  ppro.EventManager.addGlobalEventListener(
    ppro.Constants.ProjectEvent.OPENED,
    onProjectOpened
  );
  ppro.EventManager.addGlobalEventListener(
    ppro.Constants.ProjectEvent.ACTIVATED,
    onProjectActivated,
    true // in capture phase
  );
  ppro.EventManager.addGlobalEventListener(
    ppro.Constants.ProjectEvent.DIRTY,
    onProjectDirty,
    true
  );

  // add sequence event listeners
  ppro.EventManager.addGlobalEventListener(
    ppro.Constants.SequenceEvent.ACTIVATED,
    onSequenceActivated
  );
  ppro.EventManager.addGlobalEventListener(
    ppro.Constants.SequenceEvent.SELECTION_CHANGED,
    onSequenceSelectionChange
  );

  // add operation complete event listeners
  ppro.EventManager.addGlobalEventListener(
    ppro.Constants.OperationCompleteEvent.EFFECT_DROP_COMPLETE,
    onEffectDropped
  );

  // add snap event listeners
  ppro.EventManager.addGlobalEventListener(
    ppro.Constants.SnapEvent.TRACKITEM,
    onSnapTrackItem
  );
}
```

## File: html/src/export.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { premierepro, Sequence } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
const uxp = require("uxp") as typeof import("uxp");

import { log } from "./utils";
/**
 * Export current active sequence's current frame as PNG file
 */
export async function exportSequenceFrame(sequence: Sequence) {
  // @ts-ignore
  const folder = await uxp.storage.localFileSystem.getFolder();
  let folderDir = await folder.nativePath;

  let playerPos = await sequence.getPlayerPosition(); // ticktime obj
  const exportName = "output.png";

  log("Exporting output.png.png *(We do double extension)*");

  return ppro.Exporter.exportSequenceFrame(
    sequence,
    playerPos,
    exportName,
    folderDir,
    600, // width
    500 // height
  );
}

/**
 * Export current active sequence as MEPG2 file
 */
export async function exportSequence(sequence: Sequence) {
  // let user select preset file
  let presetFile;
  log("Please select a preset file for export");
  // @ts-ignore
  const file = await uxp.storage.localFileSystem.getFileForOpening({
    types: ["epr"],
  });
  if (file?.isFile && file.nativePath) {
    presetFile = file.nativePath;
  } else {
    log("Selection of preset file failed. Please try again");
    return false;
  }

  log("Please select folder for export");
  // @ts-ignore
  // let user choose dir for export output mpg file into
  const folder = await uxp.storage.localFileSystem.getFolder();
  let folderDir = await folder.nativePath;
  if (!folderDir) {
    log("Selection of folder for export failed. Please try again");
    return false;
  }

  let exportPath = folderDir + path.sep + "output.mpg"; // export to MPEG2
  let encoder = await ppro.EncoderManager.getManager();
  return encoder.exportSequence(
    sequence,
    ppro.Constants.ExportType.IMMEDIATELY, // export in Premiere Pro
    exportPath, // file path to export to
    presetFile // preset file
  );
}

/**
 * Get Export File Extension based on preset and sequence
 */
export async function getExportFileExtension(sequence, presetFile) {
  return ppro.EncoderManager.getExportFileExtension(sequence, presetFile);
}
```

## File: html/src/import.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { Guid, premierepro, Project, ProjectItem } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;

/**
 * Import files into project
 * @param project Input PPro project object
 * @param filePaths Array of string file paths to import
 * @returns [Boolean] if import successful
 */
export async function importFiles(project: Project, filePaths: string[]) {
  // import into current project if any
  return await project.importFiles(
    filePaths,
    true, // suppressUI
    null, // Project bin unset, should import it to project root
    false // importAsNumberedStills
  );
}

/**
 * Import sequences into project
 * @param project Input PPro project object
 * @param projectFilePath File path of project that contains sequences to import
 * @param seqIds Array of string sequences id to be imported
 * @returns [Boolean] if import successful
 */
export async function importSequences(
  project: Project,
  projectFilePath: string,
  seqIds: Guid[]
) {
  return project.importSequences(projectFilePath, seqIds);
}

/**
 * Import sequences into project
 * @param project Input PPro project object
 * @param projectFilePath File path of project that contains ae composition to import
 * @param aeCompName Name of ae composition
 * @param rootItem Root item of project that contains ae composition to import
 * @returns [Boolean] if import successful
 */
export async function importAeComponent(
  project: Project,
  projectFilePath: string,
  aeCompName: string,
  rootItem: ProjectItem
) {
  return project.importAEComps(projectFilePath, [aeCompName], rootItem);
}

/**
 * Import sequences into project
 * @param project Input PPro project object
 * @param projectFilePath File path of project that contains ae composition to import
 * @param rootItem Root item of project that contains ae composition to import
 * @returns [Boolean] if import successful
 */
export async function importAllAeComponents(
  project: Project,
  projectFilePath: string,
  rootItem: ProjectItem
) {
  return project.importAllAEComps(projectFilePath, rootItem);
}
```

## File: html/src/keyframe.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type {
  Action,
  ComponentParam,
  premierepro,
  Project,
} from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

//Gets the componenetParam
export async function getComponentParam() {
  let componentParam: ComponentParam;
  let component;
  const proj = await ppro.Project.getActiveProject();
  if (!proj) {
    log("No active project", "red");
    return;
  } else {
    const sequence = await proj.getActiveSequence();
    if (!sequence) {
      log("No sequence found", "red");
      return;
    } else {
      const videoTrack = await sequence.getVideoTrack(0);
      if (!videoTrack) {
        log("No videoTrack found", "red");
        return;
      } else {
        const trackItems = await videoTrack.getTrackItems(
          ppro.Constants.TrackItemType.CLIP,
          false
        );
        if (trackItems.length == 0) {
          log("No trackItems found", "red");
          return;
        } else {
          const componentChain = await trackItems[0].getComponentChain();
          try {
            await proj.lockedAccess(async () => {
              component = componentChain.getComponentAtIndex(1);
              componentParam = await component.getParam(1);
            });
          } catch (err) {
            log(`Error: ${err}`, "red");
            return;
          }
        }
      }
    }
  }
  return {
    componentParam: componentParam,
    project: proj,
  };
}

export async function changeTimeVarying(
  componentParam: ComponentParam,
  project: Project,
  value: boolean
) {
  let success: boolean;
  try {
    project.lockedAccess(() => {
      let setTimeVaryingAction =
        componentParam.createSetTimeVaryingAction(value);
      success = project.executeTransaction((compoundAction) => {
        compoundAction.addAction(setTimeVaryingAction);
      }, "SetTimeVaryingAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }
  return success;
}

//Sets the value of the component parameter stream.
export async function setValue() {
  const { componentParam, project } = await getComponentParam();
  const keyframe = componentParam.createKeyframe(300);

  let success = await changeTimeVarying(componentParam, project, false);
  try {
    project.lockedAccess(() => {
      if (success) {
        success = project.executeTransaction((compoundAction) => {
          log(
            `Setting the value of ${componentParam.displayName} to ${keyframe.value.value}`
          );
          var action1 = componentParam.createSetValueAction(keyframe, true);
          compoundAction.addAction(action1);
        }, "createSetValueAction");
      } else {
        return;
      }
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

//Gets the value of the component parameter stream.
export async function getStartValue() {
  const { componentParam, project } = await getComponentParam();

  let success = await changeTimeVarying(componentParam, project, false);

  if (success) {
    log(`Getting the start value of ${componentParam.displayName}`);
    return await componentParam.getStartValue();
  } else {
    return;
  }
}

//Adds a keyframe to the component parameter stream.
export async function addKeyframe() {
  const { componentParam, project } = await getComponentParam();

  let success = await changeTimeVarying(componentParam, project, true);
  try {
    project.lockedAccess(() => {
      if (success) {
        success = project.executeTransaction((compoundAction) => {
          const keyframe = componentParam.createKeyframe(500);
          log(
            `Adding a keyframe to ${componentParam.displayName} at ${keyframe.position.seconds}`
          );
          let action = componentParam.createAddKeyframeAction(keyframe);
          compoundAction.addAction(action);
        }, "createAddKeyframeAction");
      } else {
        return;
      }
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }
  return success;
}

//Gets all the keyframes of componentParam stream.
export async function getKeyframes() {
  const { componentParam } = await getComponentParam();
  return componentParam.getKeyframeListAsTickTimes();
}

//Gets all the keyframes of a componentParam at specific time.
export async function getKeyframe() {
  const { componentParam } = await getComponentParam();
  try {
    let keyframePtr = await componentParam.getKeyframePtr(
      ppro.TickTime.createWithSeconds(0)
    );
    return keyframePtr;
  } catch (e) {
    log(`Error: ${e}`);
    return;
  }
}

//Sets the keyframe interpolation.
// Must be one of the following:

// 0 KF_Interp_Mode_Linear

// 1 kfInterpMode_EaseIn_Obsolete

// 2 kfInterpMode_EaseOut_Obsolete

// 3 kfInterpMode_EaseInEaseOut_Obsolete

// 4 KF_Interp_Mode_Hold

// 5 KF_Interp_Mode_Bezier

// 6 KF_Interp_Mode_Time

// 7 kfInterpMode_TimeTransitionStart

// 8 kfInterpMode_TimeTransitionEnd
export async function setInterpolation() {
  const { componentParam, project } = await getComponentParam();

  let success = await changeTimeVarying(componentParam, project, true);
  try {
    project.lockedAccess(() => {
      if (success) {
        success = project.executeTransaction((compoundAction) => {
          let keyframe = componentParam.createKeyframe(150);
          keyframe.position = ppro.TickTime.createWithSeconds(1);
          log(
            `Adding a keyframe to ${componentParam.displayName} at ${keyframe.position.seconds}`
          );
          let action = componentParam.createAddKeyframeAction(keyframe);
          compoundAction.addAction(action);
        }, "createAddKeyframeAction");
      } else {
        return false;
      }

      if (success) {
        success = project.executeTransaction((compoundAction) => {
          const action = componentParam.createSetInterpolationAtKeyframeAction(
            ppro.TickTime.createWithSeconds(1),
            ppro.Constants.InterpolationMode.BEZIER
          );
          compoundAction.addAction(action);
        }, "createSetInterpolationAtKeyframeAction");
      } else {
        return false;
      }
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}
```

## File: html/src/markers.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type {
  Color,
  Marker,
  premierepro,
  Project,
  Sequence,
} from "../types.d.ts";
import { getClipProjectItem } from "./projectPanel.js";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

//Returning the sequence markers and clip markers objects from sequence and project root items respectivily

export async function getMarkerObjects(project: Project) {
  const projectItem = await getClipProjectItem(project);
  if (!projectItem) {
    log("No clip project item found.", "red");
    return;
  }

  const sequence = await project.getActiveSequence();
  if (!sequence) {
    log("No sequence found.", "red");
    return;
  }

  const sequenceMarkers = await ppro.Markers.getMarkers(sequence);
  const clipMarkers = await ppro.Markers.getMarkers(projectItem);

  if (!sequenceMarkers || !clipMarkers) {
    log("No Sequence Markers or Clip Markers found.", "red");
    return;
  }

  return { sequenceMarkers, clipMarkers };
}

export async function createMarkerComment(project) {
  const { sequenceMarkers } = await getMarkerObjects(project);

  let success = false;

  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const addMarkerAction = sequenceMarkers.createAddMarkerAction(
          "CommentMarker",
          ppro.Marker.MARKER_TYPE_COMMENT,
          ppro.TickTime.createWithSeconds(0.0),
          ppro.TickTime.TIME_ZERO,
          "This is a comment marker"
        );
        compoundAction.addAction(addMarkerAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function createMarkerChapter(project: Project) {
  const { sequenceMarkers } = await getMarkerObjects(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const addMarkerAction = sequenceMarkers.createAddMarkerAction(
          "ChapterMarker",
          ppro.Marker.MARKER_TYPE_CHAPTER,
          ppro.TickTime.createWithSeconds(0.5),
          ppro.TickTime.TIME_ZERO,
          "This is a chapter marker"
        );
        compoundAction.addAction(addMarkerAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function createMarkerWeblink(project: Project) {
  const { sequenceMarkers } = await getMarkerObjects(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const addMarkerAction = sequenceMarkers.createAddMarkerAction(
          "WeblinkMarker",
          ppro.Marker.MARKER_TYPE_WEBLINK,
          ppro.TickTime.createWithSeconds(1.0),
          ppro.TickTime.TIME_ZERO,
          "This is a weblink marker"
        );
        compoundAction.addAction(addMarkerAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function createMarkerFlashCuePoint(project: Project) {
  const { sequenceMarkers } = await getMarkerObjects(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const addMarkerAction = sequenceMarkers.createAddMarkerAction(
          "FlashCuePointMarker",
          ppro.Marker.MARKER_TYPE_FLVCUEPOINT,
          ppro.TickTime.createWithSeconds(1.5),
          ppro.TickTime.TIME_ZERO,
          "This is a Flash Cue Point marker"
        );
        compoundAction.addAction(addMarkerAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function moveMarker(project: Project) {
  const { sequenceMarkers } = await getMarkerObjects(project);

  let markerlist: Array<Marker> = await sequenceMarkers.getMarkers();
  let marker = markerlist[0];

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const moveMarkerAction = sequenceMarkers.createMoveMarkerAction(
          marker,
          ppro.TickTime.createWithSeconds(3.0)
        );
        compoundAction.addAction(moveMarkerAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function removeMarker(project: Project) {
  const { sequenceMarkers } = await getMarkerObjects(project);

  let markerlist = await sequenceMarkers.getMarkers();

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        for (let marker of markerlist) {
          const removeMarkerAction =
            sequenceMarkers.createRemoveMarkerAction(marker);
          compoundAction.addAction(removeMarkerAction);
        }
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function getSequenceMarkerInfo(sequence: Sequence) {
  let markerInfos = [];
  try {
    const sequenceMarkersOwner = await ppro.Markers.getMarkers(sequence);
    const markers = sequenceMarkersOwner.getMarkers();
    for (let marker of markers) {
      let markerInfoObj: { name: string; type: string; color: Color } = {
      name: "",
      type: "",
      color: null
    };
      markerInfoObj.name = marker.getName();
      markerInfoObj.type = marker.getType();
      markerInfoObj.color = marker.getColor();
      markerInfos.push(markerInfoObj);
    }
  } catch (error) {
    log(error, "red");
  }
  return markerInfos;
}
```

## File: html/src/metadata.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { premierepro, Project, ProjectItem } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

// Gets the project items, returns undefined if there are no project items
export async function getProjectItems(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const projectRootItem = await project.getRootItem();
  const projectItems = await projectRootItem.getItems();

  if (!projectItems.length) {
    log("No project items found", "red");
  }
  return projectItems;
}

// Returns Project metadata
export async function getProjectMetadata(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  let projectItems = await getProjectItems(project);
  let metadata = await ppro.Metadata.getProjectMetadata(projectItems[0]);
  return metadata;
}

// Returns XMP metadata of projectitems.
export async function getXMPMetadata(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  let projectItems: Array<ProjectItem> = await getProjectItems(project);
  let xmpMetadata = await ppro.Metadata.getXMPMetadata(projectItems[0]);
  return xmpMetadata;
}

// Gets Project Column metadata
export async function getProjectColumnsMetadata(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const projectItems: Array<ProjectItem> = await getProjectItems(project);
  const metadata = await ppro.Metadata.getProjectColumnsMetadata(
    projectItems[0]
  );
  return metadata;
}

// Gets Project Panel metadata
export async function getProjectPanelMetadata() {
  const metadata = await ppro.Metadata.getProjectPanelMetadata();
  return metadata;
}

// Sets xmp metadata of one project item to another
export async function setXMPMetadata(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  let projectItems: Array<ProjectItem> = await getProjectItems(project);

  if (!(projectItems.length >= 2)) {
    log("Required at least two projectitems", "red");
  }
  let replacedXmpMetadata = await ppro.Metadata.getXMPMetadata(projectItems[0]);
  let projectItem = projectItems[1];
  let setXMPMetadataAction = await ppro.Metadata.createSetXMPMetadataAction(
    projectItem,
    replacedXmpMetadata
  );

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        compoundAction.addAction(setXMPMetadataAction);
      }, "createSetXMPMetadataAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

// Sets project metadata
export async function setProjectMetadata(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  let projectItems: Array<ProjectItem> = await getProjectItems(project);
  let projectItem1 = projectItems[0];

  const metadata =
    '<?xpacket begin="" id="W5M0MpCehiHzreSzNTczkc9d"?><x:xmpmeta xmlns:x="adobe:ns:meta/" x:xmptk="Adobe XMP Core 9.0-c001 152.deb9585, 2024/02/06-08:36:10 "><rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:premierePrivateProjectMetaData="http://ns.adobe.com/premierePrivateProjectMetaData/1.0/"><premierePrivateProjectMetaData:Column.Intrinsic.Name>Name changed</premierePrivateProjectMetaData:Column.Intrinsic.Name><premierePrivateProjectMetaData:Column.PropertyBool.Hide>True</premierePrivateProjectMetaData:Column.PropertyBool.Hide></rdf:Description></rdf:RDF></x:xmpmeta><?xpacket end="w"?>';
  let updatedFields = ["Column.Intrinsic.Name"];
  let setProjectMetadataAction =
    await ppro.Metadata.createSetProjectMetadataAction(
      projectItem1,
      metadata,
      updatedFields
    );

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        compoundAction.addAction(setProjectMetadataAction);
      }, "createSetProjectMetadataAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

// Sets project panel metadata
export async function setProjectPanelMetadata() {
  const metadata =
    "<?xml version='1.0'?><md.paths version='1.0'><metadata_path><internal>true</internal><namespace>http://ns.adobe.com/exif/1.0/</namespace><description>ColorSpace</description><entry_name>ColorSpace</entry_name><parent_id>http://ns.adobe.com/exif/1.0/</parent_id></metadata_path><metadata_path><internal>false</internal><namespace>http://amwa.tv/mxf/as/11/core/</namespace><description>audioTrackLayout</description><entry_name>audioTrackLayout</entry_name><parent_id>http://amwa.tv/mxf/as/11/core/</parent_id></metadata_path><metadata_path><internal>false</internal><namespace>http://ns.useplus.org/ldf/xmp/1.0/</namespace><description>ImageCreator</description><entry_name>ImageCreator</entry_name><parent_id>http://ns.useplus.org/ldf/xmp/1.0/</parent_id></metadata_path></md.paths>";
  const success = await ppro.Metadata.setProjectPanelMetadata(metadata);
  return success;
}

// Adds property to project metadata schema
export async function addPropertiesToMetadataSchema() {
  let success = await ppro.Metadata.addPropertyToProjectMetadataSchema(
    "name",
    "value",
    ppro.Constants.MetadataType.TEXT
  );
  return success;
}
```

## File: html/src/project.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/
import type { Guid, premierepro, Project, Sequence } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
const uxp = require("uxp") as typeof import("uxp");
import { log } from "./utils";

export async function openProject() {
  // @ts-ignore
  const file = await uxp.storage.localFileSystem.getFileForOpening({
    types: ["prproj"],
  });
  if (file?.isFile && file.nativePath) {
    try {
      return await ppro.Project.open(file.nativePath);
    } catch (e) {
      log(`Error: ${e}`);
    }
  }
}

export async function openInputProject(projectPath: string) {
  return ppro.Project.open(projectPath);
}

export async function getActiveProject() {
  return await ppro.Project.getActiveProject();
}

export async function getActiveSequence(project: Project) {
  if (project) {
    return await project.getActiveSequence();
  } else {
    log(`No project found.`, "red");
  }
}

export async function getProjectFromId(projectId: Guid) {
  return ppro.Project.getProject(projectId);
}

export async function getInsertionBin(project) {
  if (project) {
    return await project.getInsertionBin();
  } else {
    log("No project found.", "red");
  }
}

export async function getAllSequences(project: Project) {
  if (project) {
    return await project.getSequences();
  } else {
    log("No project found.", "red");
  }
}

export async function openSequence(
  project: Project,
  proposedSequence: Sequence
) {
  if (project) {
    return await project.openSequence(proposedSequence);
  } else {
    log("No project found.", "red");
  }
}

export async function pauseGrowing(pause: boolean, project: Project) {
  if (project) {
    return await project.pauseGrowing(pause);
  } else {
    log("No project found.", "red");
  }
}

export async function saveProject(project: Project) {
  if (project) {
    return await project.save();
  } else {
    log("No project found.", "red");
  }
}

export async function saveAsProject(project: Project) {
  if (project) {
    // @ts-ignore
    const file = await uxp.storage.localFileSystem.getFileForSaving(
      `newProjectCopy`,
      {
        types: ["prproj"],
      }
    );

    if (file && file.isFile && file.nativePath) {
      return await project.saveAs(file.nativePath);
    } else {
      log("User cancelled the save as activity.");
    }
  } else {
    log("No project found.", "red");
  }
}

export async function getColorSettings(project: Project) {
  if (project) {
    const colorSettings = await project.getColorSettings();
    if (!colorSettings) {
      log("Error getting project color settings.", "red");
    }

    return colorSettings;
  } else {
    log("No project found.", "red");
  }
}

export async function getSupportedGraphicsWhiteLuminances(project: Project) {
  if (project) {
    const colorSettings = await getColorSettings(project);
    return colorSettings.getSupportedGraphicsWhiteLuminances();
  } else {
    log("No project found.", "red");
  }
}

export async function getCurrentGraphicsWhiteLuminance(project: Project) {
  if (project) {
    const colorSettings = await getColorSettings(project);
    return await colorSettings.getGraphicsWhiteLuminance();
  } else {
    log("No project found.", "red");
  }
}

export async function closeProject(project: Project) {
  if (project) {
    return project.close();
  } else {
    log("No project found.", "red");
  }
}
```

## File: html/src/projectPanel.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { premierepro, Project, ProjectItem } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

export async function getRootItem(project: Project) {
  const rootItem = await project.getRootItem();
  return rootItem;
}

export async function getProjectItems(project: Project) {
  const rootItem = await getRootItem(project);
  const projectItems = await rootItem.getItems();
  return projectItems;
}

export async function getSelectedProjectItems(project: Project) {
  const projectSelection = await ppro.ProjectUtils.getSelection(project);
  const projectItems = await projectSelection.getItems();
  return projectItems;
}

export async function getClipProjectItem(project: Project) {
  const rootItem = await getRootItem(project);
  const projectItems: Array<ProjectItem> = await rootItem.getItems();

  let mediaItem;
  for (let projectItem of projectItems) {
    const clipProjectItem = ppro.ClipProjectItem.cast(projectItem);
    if (
      clipProjectItem &&
      (await clipProjectItem.getContentType()) ===
        ppro.Constants.ContentType.MEDIA
    ) {
      // Take the first media found.
      mediaItem = clipProjectItem;
      break;
    } else {
      const folderProjectItem = ppro.FolderItem.cast(projectItem);
      if (folderProjectItem) {
        let items = await folderProjectItem.getItems();
        projectItems.push(...items);
      }
    }
  }
  if (!mediaItem) {
    log("No media project item found.", "red");
    return;
  }
  return ppro.ClipProjectItem.cast(mediaItem);
}

export async function getMediaFilePath(project: Project) {
  const clipProjectItem = await getClipProjectItem(project);
  if (clipProjectItem) {
    return clipProjectItem.getMediaFilePath();
  }
  return null;
}

export async function createBin(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const rootItem = await getRootItem(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const createBinAction = rootItem.createBinAction("Bin1", true);
        compoundAction.addAction(createBinAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function createSmartBin(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const rootItem = await getRootItem(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const createBinAction = rootItem.createSmartBinAction("Bin2", "Bin");
        compoundAction.addAction(createBinAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function renameBin(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const rootItem = await getRootItem(project);

  //create a bin named Bin3

  try {
    project.lockedAccess(() => {
      project.executeTransaction((compoundAction) => {
        const createBinAction = rootItem.createBinAction("Bin3", true);
        compoundAction.addAction(createBinAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  const newItems: Array<ProjectItem> = await rootItem.getItems();

  const newBin = newItems.find((item) => item.name == "Bin3");

  //rename Bin3 to Bin3_rename
  let success = false;

  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const renameBinAction =
          ppro.FolderItem.cast(newBin).createRenameBinAction("Bin3_rename");
        compoundAction.addAction(renameBinAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function removeItem(project: Project) {
  const rootItem = await getRootItem(project);

  //create a bin named Bin4
  try {
    project.lockedAccess(() => {
      project.executeTransaction((compoundAction) => {
        const createBinAction = rootItem.createBinAction("Bin4", true);
        compoundAction.addAction(createBinAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }
  const newItems: Array<ProjectItem> = await rootItem.getItems();

  const newBin = newItems.find((item) => item.name == "Bin4");

  //setTimeout is not mandatory here, wrapping inside setTimeout to make removeItem feature visisble on project panel.
  setTimeout(async () => {
    let success = false;
    try {
      project.lockedAccess(() => {
        success = project.executeTransaction((compoundAction) => {
          const createRemoveItemAction = rootItem.createRemoveItemAction(
            ppro.FolderItem.cast(newBin)
          );
          compoundAction.addAction(createRemoveItemAction);
        });
      });
    } catch (err) {
      log(`Error: ${err}`, "red");
      return false;
    }

    if (success) {
      log("Successfully removed the item form project panel");
    }
  }, 1000);
}

export async function moveItem(project: Project) {
  const rootItem = await getRootItem(project);
  try {
    project.lockedAccess(() => {
      project.executeTransaction((compoundAction) => {
        const createBinAction = rootItem.createBinAction("Bin5", true);
        compoundAction.addAction(createBinAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  try {
    project.lockedAccess(() => {
      project.executeTransaction((compoundAction) => {
        const createBinAction = rootItem.createBinAction("Bin6", true);
        compoundAction.addAction(createBinAction);
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  const newItems: Array<ProjectItem> = await rootItem.getItems();

  const newBin1 = newItems.find((item) => item.name == "Bin5");
  const newBin2 = newItems.find((item) => item.name == "Bin6");

  //setTimeout is not mandatory here, wrapping inside setTimeout to make moveitem feature visisble on project panel.
  setTimeout(async () => {
    let success = false;
    try {
      project.lockedAccess(() => {
        success = project.executeTransaction((compoundAction) => {
          const createMoveItemAction = rootItem.createMoveItemAction(
            ppro.FolderItem.cast(newBin1),
            ppro.FolderItem.cast(newBin2)
          );
          compoundAction.addAction(createMoveItemAction);
        });
      });
    } catch (err) {
      log(`Error: ${err}`, "red");
      return false;
    }

    if (success) {
      log("Successfully moved the item to another bin");
    }
  }, 1000);
}

export async function setInOutPoint(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const inPoint = ppro.TickTime.createWithSeconds(2);
  const outPoint = ppro.TickTime.createWithSeconds(4);
  const clipProjectItem = await getClipProjectItem(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        let action = clipProjectItem.createSetInOutPointsAction(
          inPoint,
          outPoint
        );
        compoundAction.addAction(action);
      }, "createSetInOutPointsAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function clearInOutPoint(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const clipProjectItem = await getClipProjectItem(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        let action = clipProjectItem.createClearInOutPointsAction();
        compoundAction.addAction(action);
      }, "createClearInOutPointsAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function setScaleToFrameSize(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const clipProjectItem = await getClipProjectItem(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        let action = clipProjectItem.createSetScaleToFrameSizeAction();
        compoundAction.addAction(action);
      }, "createSetScaleToFrameSizeAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}
export async function refreshMedia(project: Project) {
  const clipProjectItem = await getClipProjectItem(project);
  const success = await clipProjectItem.refreshMedia();
  return success;
}

export async function setFootageInterpretation(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const clipProjectItem = await getClipProjectItem(project);
  let interpretation = await clipProjectItem.getFootageInterpretation();
  await interpretation.setFrameRate(20);
  await interpretation.setPixelAspectRatio(1.5);
  let createSetFootageInterpretationAction =
    await clipProjectItem.createSetFootageInterpretationAction(interpretation);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        compoundAction.addAction(createSetFootageInterpretationAction);
      }, "createSetFootageInterpretationAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}
export async function setOverrideFrameRate(project: Project) {
  const clipProjectItem = await getClipProjectItem(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        let action = clipProjectItem.createSetOverrideFrameRateAction(0.5);
        compoundAction.addAction(action);
      }, "createSetOverrideFrameRateAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function setOverridePixelAspectRatio(project: Project) {
  const clipProjectItem = await getClipProjectItem(project);

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        let action = clipProjectItem.createSetOverridePixelAspectRatioAction(
          1,
          2
        );
        compoundAction.addAction(action);
      }, "createSetOverridePixelAspectRatioAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

/**
 * Note:
 * If inHighRes is set to true, we will attach input file as high resolution footage.
 * If inHighRes is set to false, we will attach input file as proxy to projectItem without changing its media content.
 */
export async function attachProxy(project: Project, proxyFile: string) {
  const clipProjectItem = await getClipProjectItem(project);
  let success = false;
  try {
    success = await clipProjectItem.attachProxy(
      proxyFile,
      false // inHighRes, attach as proxy file
    );
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }
  return success;
}

export async function changeMediaFilePath(project: Project, mediaFile: string) {
  const clipProjectItem = await getClipProjectItem(project);
  let success = false;
  try {
    success = await clipProjectItem.changeMediaFilePath(mediaFile);
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }
  return success;
}

export async function getProjectViewIds() {
  return ppro.ProjectUtils.getProjectViewIds();
}

export async function getProjectFromViewId(viewId) {
  return ppro.ProjectUtils.getProjectFromViewId(viewId);
}

export async function getSelectedProjectItemsFromViewId(viewId) {
  const projectItemSelection = await ppro.ProjectUtils.getSelectionFromViewId(
    viewId
  );
  return projectItemSelection.getItems();
}

export async function renameFirstSelectedProjectItem(project: Project) {
  const selectedItems = await getSelectedProjectItems(project);
  if (selectedItems.length == 0) {
    log("No ProjectItem selected for rename");
    return false;
  }
  let success = false;
  try {
    project.lockedAccess(() => {
      const renameAction = selectedItems[0].createSetNameAction("Item 1");
      success = project.executeTransaction((compoundAction) => {
        compoundAction.addAction(renameAction);
      }, "rename projectItem to Item 1");
    });
  } catch (error) {
    log(error, "red");
  }
  return success;
}

export async function getMediaInfo(project: Project) {
  try {
    const clipProjectItem = await getClipProjectItem(project);
    if (!clipProjectItem) {
      log("No ClipProjectItem found in project panel");
    }
    const media = await clipProjectItem.getMedia();
    if (!media) {
      log("Failed to access media");
    }
    const start = await media.start;
    const duration = await media.duration;
    return {
      name: clipProjectItem.name,
      start: start.seconds,
      duration: duration.seconds,
    };
  } catch (error) {
    log(error, "red");
  }
  return null;
}

export async function setMediaStart(project: Project) {
  let success = false;
  try {
    const clipProjectItem = await getClipProjectItem(project);
    if (!clipProjectItem) {
      log("No ClipProjectItem found in project panel");
    }
    const media = await clipProjectItem.getMedia();
    if (!media) {
      log("Failed to access media");
    }
    const duration = await media.duration;
    if (duration < ppro.TickTime.TIME_ONE_SECOND) {
      log("Media Duration is smaller than 1 second");
    }

    project.lockedAccess(() => {
      const mediaSetStartAction = media.createSetStartAction(
        ppro.TickTime.TIME_ONE_SECOND
      );
      success = project.executeTransaction((compoundAction) => {
        compoundAction.addAction(mediaSetStartAction);
      });
    });
  } catch (error) {
    log(error, "red");
  }
  return success;
}
```

## File: html/src/properties.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { premierepro, Project, Sequence } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

const NEW_PROPERTY_NAME = "Sample";

/**
 * Get input sequence's property object
 * @return [Property Object] PPro property object
 */
export async function getSequenceProperty(sequence: Sequence) {
  return ppro.Properties.getProperties(sequence);
}

/**
 * Get input sequence's sample property value if it is defined
 * @return [string] value of "Sample" property
 */
export async function getSequenceSampleProperty(sequence: Sequence) {
  try {
    const properties = await getSequenceProperty(sequence);
    let value = properties.getValue(NEW_PROPERTY_NAME);
    return value;
  } catch (err) {
    log(`No value has been defined for property "${NEW_PROPERTY_NAME}"`);
    throw err;
  }
}

/**
 * Set a example new property to input sequencev
 * @return [Boolean] if operation succeed
 */
export async function setSampleSequenceProperty(
  sequence: Sequence,
  project: Project
) {
  const properties = await getSequenceProperty(sequence);
  let newPropertyValue = 88;

  let succeed = false;
  try {
    project.lockedAccess(() => {
      let setValueAction = properties.createSetValueAction(
        NEW_PROPERTY_NAME,
        newPropertyValue,
        ppro.Constants.PropertyType.NON_PERSISTENT
      );

      project.lockedAccess(() => {
        succeed = project.executeTransaction((compoundAction) => {
          compoundAction.addAction(setValueAction);
        });
      });
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }
  return succeed;
}

/**
 * Clear the added sequence property
 * @return [Bool] if operation succeed
 */
export async function clearSampleSequenceProperty(
  sequence: Sequence,
  project: Project
) {
  // check if property exist and log error message as needed
  let value = await getSequenceSampleProperty(sequence);
  let succeed;
  if (value) {
    const properties = await getSequenceProperty(sequence);
    log(`Removing property "${NEW_PROPERTY_NAME}"..`);
    try {
      project.lockedAccess(() => {
        succeed = project.executeTransaction((compoundAction) => {
          let clearValueAction =
            properties.createClearValueAction(NEW_PROPERTY_NAME);
          compoundAction.addAction(clearValueAction);
        });
      });
    } catch (err) {
      log(`Error: ${err}`, "red");
      return false;
    }
  }
  return succeed;
}
```

## File: html/src/sequence.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type {
  AudioClipTrackItem,
  ClipProjectItem,
  Guid,
  premierepro,
  Project,
  ProjectItem,
  Sequence,
  SequenceSettings,
  VideoClipTrackItem,
} from "../types.d.ts";
import { getClipProjectItem } from "./projectPanel.js";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

const MEDIA_START_COLUMN_ID = "Column.Intrinsic.MediaStart";
const MEDIA_END_COLUMN_ID = "Column.Intrinsic.MediaEnd";

async function getInfoFromSettings(settings: SequenceSettings) {
  const frameRect = await settings.getVideoFrameRect();
  const par = await settings.getVideoPixelAspectRatio();
  const field = await settings.getVideoFieldType();
  const displayFormat = await settings.getVideoDisplayFormat();

  let fieldType = "No Fields";
  if (field == ppro.Constants.VideoFieldType.LOWER_FIRST) {
    fieldType = "Lower Field First";
  } else if (field == ppro.Constants.VideoFieldType.UPPER_FIRST) {
    fieldType = "Upper Field First";
  }

  let displayFormatType = "";
  switch (displayFormat.type) {
    case ppro.Constants.VideoDisplayFormatType.FEET_FRAME_16mm:
      displayFormatType = "Feet+Frames 16mm";
      break;
    case ppro.Constants.VideoDisplayFormatType.FEET_FRAME_35mm:
      displayFormatType = "Feet+Frames 35mm";
      break;
    case ppro.Constants.VideoDisplayFormatType.FPS_23_976:
      displayFormatType = "23.976 fps";
      break;
    case ppro.Constants.VideoDisplayFormatType.FPS_25:
      displayFormatType = "25 fps";
      break;
    case ppro.Constants.VideoDisplayFormatType.FPS_29_97:
      displayFormatType = "29.97 fps";
      break;
    case ppro.Constants.VideoDisplayFormatType.FPS_29_97_NON_DROP:
      displayFormatType = "29.97 fps Non-Drop-Frame Timecode";
      break;
    case ppro.Constants.VideoDisplayFormatType.FRAMES:
      displayFormatType = "Frames";
      break;
    default:
      displayFormatType = `Format Code: ${displayFormat.type}`;
      break;
  }

  return [
    `Video Frame Size: ${frameRect.height}; Horizontal ${frameRect.width}`,
    `Pixel Aspect Ratio: ${par}`,
    `Fields: ${fieldType}`,
    `Display Format: ${displayFormatType}`,
  ];
}

export async function getVideoSettingsInfo(sequence: Sequence) {
  const settings = await sequence.getSettings();
  return getInfoFromSettings(settings);
}

export async function setSequencePixelAsepctRatio(
  project: Project,
  sequence: Sequence
) {
  const settings = await sequence.getSettings();
  let success = false;
  try {
    success = await settings.setVideoPixelAspectRatio(
      ppro.Constants.PixelAspectRatio.SQUARE.toString()
    );
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const setSettingsAction = sequence.createSetSettingsAction(settings);
        compoundAction.addAction(setSettingsAction);
      }, "set sequence pixel aspect ratio to square");
    });
  } catch (err) {
    log(err.toString(), "red");
  }
  return success;
}

export async function setSequenceInOutPoint(
  project: Project,
  sequence: Sequence
) {
  let success = false;
  try {
    const sequenceEnd = await sequence.getEndTime();
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        const setInPointAction = sequence.createSetInPointAction(
          ppro.TickTime.TIME_ZERO
        );
        const setOutPoitAction = sequence.createSetOutPointAction(sequenceEnd);
        compoundAction.addAction(setInPointAction);
        compoundAction.addAction(setOutPoitAction);
      }, "set sequence in point to 0 and out point to sequence end");
    });
  } catch (err) {
    log(err.toString(), "red");
  }
  return success;
}

export async function getSequence(project: Project, sequenceGuid: Guid) {
  if (project) {
    return await project.getSequence(sequenceGuid);
  } else {
    log("No project found.");
  }
}

export async function setActiveSequence(project: Project, sequence: Sequence) {
  if (project) {
    return await project.setActiveSequence(sequence);
  } else {
    log("No project found.");
  }
}

export async function createSequence(project: Project, sequenceName: string) {
  if (project) {
    return await project.createSequence(sequenceName);
  } else {
    log("No project found.");
  }
}

export async function createSequenceFromMedia(
  project: Project,
  sequenceName: string
) {
  if (project) {
    let mediaItem = await getClipProjectItem(project);
    if (!mediaItem) {
      log("No media item found in the project.");
      return;
    }

    return project.createSequenceFromMedia(sequenceName, [mediaItem]);
  } else {
    log("No project found.");
  }
}

// getVideoTrackCount() and getAudioTrackCount() are also available
export async function getCaptionTrackCount(sequence: Sequence) {
  if (sequence) {
    return await sequence.getCaptionTrackCount();
  } else {
    log("No sequence found.");
  }
}

//getCaptionTrack and getAudioTrack are also available
export async function getVideoTrack(sequence: Sequence, trackIndex: number) {
  if (sequence) {
    const videoTrackCount = await sequence.getVideoTrackCount();
    if (trackIndex + 1 > videoTrackCount) {
      log(`Video track index should be less than ${videoTrackCount}`);
      return;
    }

    return await sequence.getVideoTrack(trackIndex);
  } else {
    log("No sequence found.");
  }
}

export async function getSequenceSelection(sequence: Sequence) {
  if (sequence) {
    return sequence.getSelection();
  } else {
    log("No sequence found.");
  }
}

export async function setSequenceSelection(sequence: Sequence) {
  if (sequence) {
    let trackItemSelection = await sequence.getSelection();

    const videoTrack = await sequence.getVideoTrack(0);
    const videoTrackItems = videoTrack.getTrackItems(
      ppro.Constants.TrackItemType.CLIP,
      false
    );

    if (videoTrackItems.length === 0) {
      log(`No video tracks found for the sequence ${sequence.name}.`);
    }
    trackItemSelection.addItem(videoTrackItems[0], false);

    return await sequence.setSelection(trackItemSelection);
  } else {
    log("No sequence found.");
  }
}

export async function createSubsequence(sequence: Sequence) {
  if (sequence) {
    try {
      return await sequence.createSubsequence(true);
    } catch (err) {
      log("Error:" + err.toString());
    }
  } else {
    log("No sequence found.");
  }
}

export async function trimSelectedItem(project: Project, sequence: Sequence) {
  let success = false;
  if (sequence) {
    try {
      const selection = await sequence.getSelection();
      const items: Array<VideoClipTrackItem | AudioClipTrackItem> =
        await selection.getTrackItems();
      if (items.length > 0) {
        const oldEnd = await items[0].getEndTime();
        // Note: This is not the best approach for precise TickTime calculation for trim
        // We are working on method that offers direct TickTime object calculation
        // For precise time calculation, please refer to steps at addHandlesToTrackItem
        const newEnd = ppro.TickTime.createWithSeconds(oldEnd.seconds - 1.0);
        project.lockedAccess(() => {
          success = project.executeTransaction((compoundAction) => {
            var action1 = items[0].createSetEndAction(newEnd);
            compoundAction.addAction(action1);
          }, "Trim end of item by 1 second");
        });
      } else {
        throw new Error("no trackItem is selected at sequence");
      }
    } catch (err) {
      log(err.toString(), "red");
      return success;
    }
  } else {
    log("No sequence found.");
  }
  return success;
}

/*
 * Return media start and end time of input projectItem
 */
async function getMediaStartEndTime(projectItem: ProjectItem) {
  const projectItemMetadata = await ppro.Metadata.getProjectColumnsMetadata(
    projectItem
  );
  const projItemMetadataJson = JSON.parse(projectItemMetadata);
  let projItemStartTime;
  let projItemEndTime;
  for (let currentMetadata of projItemMetadataJson) {
    if (projItemStartTime && projItemEndTime) {
      break;
    } else if (currentMetadata.ColumnID == MEDIA_START_COLUMN_ID) {
      projItemStartTime = ppro.TickTime.createWithTicks(
        currentMetadata.ColumnValue
      );
    } else if (currentMetadata.ColumnID == MEDIA_END_COLUMN_ID) {
      projItemEndTime = ppro.TickTime.createWithTicks(
        currentMetadata.ColumnValue
      );
    }
  }
  return [projItemStartTime, projItemEndTime];
}

/*
 * Add media handles to both the start and end of a track item.  Adding a handle
 * value of 1 frame to the start and end will add 1 frame of media to the start
 * of the track item, and add 1 frame of media to the end of the track item.
 *
 * To truncate clips, a negative offset value may be used (effectively removing,
 * rather than adding, media handles).
 *
 * @param project The current working project
 * @param trackItemToChange The target track item to modify
 * @param inPointOffsetFrames The number of frames to add to the start of the track item in the sequence
 * @param outPointOffsetFrames The number of frames to add to the end of the track item in the sequence
 * @returns boolean, where true indicates success, and false indicates faiure
 */
export async function addHandlesToTrackItem(
  project: Project,
  sequence: Sequence,
  trackItemToChange: VideoClipTrackItem | AudioClipTrackItem,
  inPointOffsetFrames: number = 0,
  outPointOffsetFrames: number = 0
) {
  let success = false;

  if (trackItemToChange) {
    if (
      !Number.isInteger(inPointOffsetFrames) ||
      !Number.isInteger(outPointOffsetFrames)
    ) {
      throw new Error("Frame offset arguments must be integers.");
    }

    try {
      const ticksPerSec = 254016000000;
      const projItem = await trackItemToChange.getProjectItem();
      const clipProjItem: ClipProjectItem = await ppro.ClipProjectItem.cast(
        projItem
      );
      if (!clipProjItem) {
        throw new Error("Invalid trackItem type");
      }
      const [mediaStartTime, mediaEndTime] = await getMediaStartEndTime(
        projItem
      );
      // Get frame rate of media and sequence
      const footageInterpretation =
        await clipProjItem.getFootageInterpretation();
      const projItemTimeBase = await footageInterpretation.getFrameRate();
      const sequenceTimeBase =
        ticksPerSec / Number(await sequence.getTimebase());
      const projItemFrameRate =
        ppro.FrameRate.createWithValue(projItemTimeBase);
      const sequenceFrameRate =
        ppro.FrameRate.createWithValue(sequenceTimeBase);

      // Get in point ticks relative to media start.
      // Ex. Media starts at 1min and In point is set as 1min1s, in point = 1s
      const originalInPoint = await trackItemToChange.getInPoint();
      const originalOutPoint = await trackItemToChange.getOutPoint();
      const originalInPointTicks = originalInPoint.ticksNumber;
      const originalOutPointTicks = originalOutPoint.ticksNumber;

      // Get in point ticks in absolute value.
      // Ex. Media start starts at 1min, absolute in point value is 1min1s.
      const absoluteInPointTicks =
        originalInPointTicks + mediaStartTime.ticksNumber;
      const absoluteOutPointTicks =
        originalOutPointTicks + mediaStartTime.ticksNumber;

      const inPointOffset = ppro.TickTime.createWithFrameAndFrameRate(
        inPointOffsetFrames,
        projItemFrameRate
      );
      const outPointOffset = ppro.TickTime.createWithFrameAndFrameRate(
        outPointOffsetFrames,
        projItemFrameRate
      );

      // We need to consider the source and sequence timebases, since we're adding handles at the sequence level,
      // but using the source timebase to modify the in/out of the trackItem source to establish those handles.
      //
      // For Example:  With a sequence at 30FPS and a source clip at 60FPS, we need to add 60 frames of source
      // in order to add 30 frames of handle at the sequence level.
      // Calculate new In/Out points. Compensate for source:sequence timebase ratio.
      const sourceSeqTimeBaseRatio =
        projItemFrameRate.value / sequenceFrameRate.value;
      const inPointOffsetTicks =
        inPointOffset.ticksNumber * sourceSeqTimeBaseRatio;
      const outPointOffsetTicks =
        outPointOffset.ticksNumber * sourceSeqTimeBaseRatio;

      const newAbsInPointTicks = absoluteInPointTicks - inPointOffsetTicks;
      const newAbsOutPointTicks = absoluteOutPointTicks + outPointOffsetTicks;
      const newInPointTicks = originalInPointTicks - inPointOffsetTicks;
      const newOutPointTicks = originalOutPointTicks + outPointOffsetTicks;

      if (
        newAbsInPointTicks >= mediaStartTime.ticksNumber &&
        newAbsOutPointTicks <= mediaEndTime.ticksNumber
      ) {
        project.lockedAccess(() => {
          success = project.executeTransaction((compoundAction) => {
            var action1 = trackItemToChange.createSetInPointAction(
              ppro.TickTime.createWithTicks(String(newInPointTicks))
            );

            var action2 = trackItemToChange.createSetOutPointAction(
              ppro.TickTime.createWithTicks(String(newOutPointTicks))
            );
            compoundAction.addAction(action1);
            compoundAction.addAction(action2);
          }, `Add Handles [${inPointOffsetFrames}F, ${outPointOffsetFrames}F]`);
        });
      } else {
        log(
          "Could not adjust trackItem in/out points due to media limits.",
          "red"
        );
      }
    } catch (err) {
      log(err.toString(), "red");
    }
  } else {
    log("No track item provided.", "red");
  }
  return success;
}

export async function renameFirstSelectedTrackItem(
  project: Project,
  sequence: Sequence
) {
  const selection = await sequence.getSelection();
  const items = await selection.getTrackItems();
  if (items.length == 0) {
    log("No trackItem is selected for rename");
    return false;
  }
  let success = false;
  try {
    project.lockedAccess(() => {
      const renameAction = items[0].createSetNameAction("TrackItem 1");
      success = project.executeTransaction((compoundAction) => {
        compoundAction.addAction(renameAction);
      }, "rename trackItem to TrackItem 1");
    });
  } catch (error) {
    log(error, "red");
  }
  return success;
}
```

## File: html/src/sequenceEditor.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2025 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type {
  AudioClipTrackItem,
  premierepro,
  Project,
  ProjectItem,
  VideoClipTrackItem,
} from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { getSelectedProjectItems } from "./projectPanel";
import { log } from "./utils";

/**
 * Use first selected projectItem to create new trackItem that overwrites at V2/A2 of active sequence
 * Please note that input is NOT offset. Inputing 2 for video track index will always overwrite trackItem at V3.
 */
export async function overwriteTrackItem(project: Project) {
  let success = false;
  const sequence = await project.getActiveSequence();
  if (sequence) {
    try {
      const sequenceEditor = ppro.SequenceEditor.getEditor(sequence);
      const projectItems: Array<ProjectItem> = await getSelectedProjectItems(
        project
      );
      if (projectItems.length == 0) {
        throw new Error(
          "No projectItem selected in project panel for overwrite"
        );
      }
      project.lockedAccess(() => {
        success = project.executeTransaction((compoundAction) => {
          const overwriteItemAction = sequenceEditor.createOverwriteItemAction(
            projectItems[0], // projectItem reference for creating trackItem
            ppro.TickTime.TIME_ZERO, // Overwrite at beginning of timeline
            1, // video track index (V2)
            1 // audio track index (A2)
          );
          compoundAction.addAction(overwriteItemAction);
        }, "TrackItem Overwritten");
      });
    } catch (err) {
      log(`${err}`, "red");
      return false;
    }
  } else {
    log("No sequence available for edits", "red");
  }
  return success;
}

/**
 * Use first selected projectItem to create new trackItem to inserted at V2/A2 at active sequence
 * Please note that input is NOT offset. Inputing 2 for video track index will always insert new trackItem at V3.
 */
export async function insertTrackItem(project: Project) {
  let success = false;
  const sequence = await project.getActiveSequence();
  if (sequence) {
    try {
      const sequenceEditor = ppro.SequenceEditor.getEditor(sequence);
      const projectItems: Array<ProjectItem> = await getSelectedProjectItems(
        project
      );
      if (projectItems.length == 0) {
        throw new Error("No projectItem selected in project panel for insert");
      }
      project.lockedAccess(() => {
        success = project.executeTransaction((compoundAction) => {
          const insertItemAction = sequenceEditor.createInsertProjectItemAction(
            projectItems[0], // reference for creating trackItem for overwrite
            ppro.TickTime.TIME_ZERO, // time
            1, // video track index
            1, // audio track index
            true // limitedShift, don't shift non-input track for this insert
          );
          compoundAction.addAction(insertItemAction);
        }, "TrackItem Inserted");
      });
    } catch (err) {
      log(`${err}`, "red");
      return false;
    }
  } else {
    log("No sequence available for edits", "red");
  }
  return success;
}

/**
 * Clone first selected trackItem to another track (with index + 1) and 1 second leftward in time
 * Please note that input for this API is offset compared to input trackItem data, which could be negative.
 * For example, if input trackItem is located at V1, it will be cloned at V2.
 * If your input trackItem is located at V2, it will be cloned at V3.
 * If your input trackItem ends at 00:00:12:00, cloned item will end at 00:00:11:00.
 * If you do not specify for if it's insert or not, default is overwrite.
 */
export async function cloneSelectedTrackItem(project: Project) {
  let success = false;
  const sequence = await project.getActiveSequence();
  if (sequence) {
    try {
      const trackItemSelection = await sequence.getSelection();
      const selectedItems: Array<VideoClipTrackItem | AudioClipTrackItem> =
        await trackItemSelection.getTrackItems();
      if (selectedItems.length == 0) {
        throw new Error("No trackItem is selected at sequence for clone");
      }
      const sequenceEditor = ppro.SequenceEditor.getEditor(sequence);
      const timeOffset = ppro.TickTime.createWithSeconds(-1);
      project.lockedAccess(() => {
        success = project.executeTransaction((compoundAction) => {
          const cloneItemAction = sequenceEditor.createCloneTrackItemAction(
            selectedItems[0], // use first selected trackItem for clone
            timeOffset, // shift it 1s leftward
            1, // new trackItem video track index go up by 1 if apply
            1, // new trackItem audio track index go up by 1 if apply
            true, // alignToVideo
            true // Insert, not overwrite
          );
          compoundAction.addAction(cloneItemAction);
        }, "TrackItem cloned");
      });
    } catch (err) {
      log(`${err}`, "red");
      return false;
    }
  } else {
    log("No sequence available for edits", "red");
  }
  return success;
}

/**
 * Remove selected trackItems at active sequence by ripple delete
 */
export async function removeSelectedTrackItems(project: Project) {
  let success = false;
  const sequence = await project.getActiveSequence();
  if (sequence) {
    try {
      const trackItemSelection = await sequence.getSelection();
      const selectedItems: Array<VideoClipTrackItem | AudioClipTrackItem> =
        await trackItemSelection.getTrackItems();
      if (selectedItems.length == 0) {
        throw new Error("No trackItem is selected at sequence for removal");
      }
      const sequenceEditor = ppro.SequenceEditor.getEditor(sequence);
      project.lockedAccess(() => {
        success = project.executeTransaction((compoundAction) => {
          const removeItemAction = sequenceEditor.createRemoveItemsAction(
            trackItemSelection, // selection of items to be removed
            true, // ripple delete
            ppro.Constants.MediaType.VIDEO // align moved track items to the start of the nearest video frame
          );
          compoundAction.addAction(removeItemAction);
        }, "TrackItem removed");
      });
    } catch (err) {
      log(`${err}`, "red");
      return false;
    }
  } else {
    log("No sequence available for edits", "red");
  }
  return success;
}

/**
 * Insert mogrt at active sequence V2
 */
export async function insertMogrt(project: Project, mogrtPath: string) {
  let mogrtItems = [];
  const sequence = await project.getActiveSequence();
  if (sequence) {
    try {
      const sequenceEditor = ppro.SequenceEditor.getEditor(sequence);
      project.lockedAccess(() => {
        mogrtItems = sequenceEditor.insertMogrtFromPath(
          mogrtPath, // path to mogrt file
          ppro.TickTime.TIME_ZERO, // time to insert at
          1, // video track index
          1 // audio track index
        );
      });
    } catch (err) {
      log(`${err}`, "red");
      return false;
    }
  } else {
    log("No sequence available for edits", "red");
  }
  return mogrtItems.length > 0;
}
```

## File: html/src/settings.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { premierepro, Project, Sequence } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

/**
 * Get input project's scratch disk path in its settings
 * @return [string] Scratch Disk Path of current project
 */
export async function getScratchDiskSetting(project: Project) {
  const projectSettings = ppro.ProjectSettings;
  const scratchDiskSettings = await projectSettings.getScratchDiskSettings(
    project
  );
  return scratchDiskSettings.getScratchDiskPath(
    ppro.Constants.ScratchDiskFolderType.VIDEO_CAPTURE
  );
}

/**
 * Set scratch Disk path to MyDocuments
 * @return [bool] if set action succeed or not
 */
export async function setScratchDiskSettings(project: Project) {
  const projectSettings = ppro.ProjectSettings;
  const scratchDiskSettings = await projectSettings.getScratchDiskSettings(
    project
  );
  // set to documents
  await scratchDiskSettings.setScratchDiskPath(
    ppro.Constants.ScratchDiskFolderType.VIDEO_CAPTURE,
    ppro.Constants.ScratchDiskFolder.MY_DOCUMENTS
  );

  let succeed = false;
  try {
    project.lockedAccess(() => {
      succeed = project.executeTransaction((compoundAction) => {
        var action = projectSettings.createSetScratchDiskSettingsAction(
          project,
          scratchDiskSettings
        );
        compoundAction.addAction(action);
      }, "createSetScratchDiskPathAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return succeed;
}

/**
 * Get if ingest enabled in project's ingest setting
 * @return [bool] If ingest is enabled for current project
 */
export async function getIngestEnabled(project: Project) {
  const projectSettings = ppro.ProjectSettings;
  const ingestSettings = await projectSettings.getIngestSettings(project);
  return ingestSettings.getIsIngestEnabled();
}

/**
 * Set ingest enabled to true for current project's ingest settings
 * @return [bool] if set action succeed or not
 */
export async function setIngestEnabled(project: Project) {
  const projectSettings = ppro.ProjectSettings;
  const ingestSettings = await projectSettings.getIngestSettings(project);
  // set to enabled
  await ingestSettings.setIngestEnabled(true);

  let succeed = false;
  try {
    project.lockedAccess(() => {
      succeed = project.executeTransaction((compoundAction) => {
        var action = projectSettings.createSetIngestSettingsAction(
          project,
          ingestSettings
        );
        compoundAction.addAction(action);
      }, "set ingest enabled");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return succeed;
}
```

## File: html/src/sourceMonitor.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { premierepro, ProjectItem } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
const uxp = require("uxp") as typeof import("uxp");
import { log } from "./utils";

/// Source Monitor html helper functions
/**
 * add list of projectItems in current active project as options in select
 * html component
 */
export async function addProjectItemsOptions() {
  let items = document.getElementById("project-items");
  // get projectItems from current active project
  const proj = await ppro.Project.getActiveProject();
  if (!proj) {
    log(`Load projectItems failed. Cannot find active project.`);
    return;
  }
  const projectRootItem = await proj.getRootItem();
  let projectItems: Array<ProjectItem> = await projectRootItem.getItems();

  if (!projectItems) {
    log(`Project Empty. Cannot find valid projectItem to open`);
    return;
  }
  // insert them as option
  for (let i = 0; i < projectItems.length; i++) {
    let option = document.createElement("option");
    option.innerText = projectItems[i].name;
    option.value = projectItems[i].name;
    items.appendChild(option);
  }
}

/**
 * clear options for projectItems under select
 */
export async function clearProjectItemOptions() {
  let items = document.getElementById("project-items");
  items.innerHTML = "";
}

/**
 * refresh projectItems options
 */
export async function refreshProjectItemOptions() {
  clearProjectItemOptions();
  await addProjectItemsOptions();
}

/// Source Monitor utility functions
/**
 * get projectItem opened at source monitor
 * @returns PPro projectItem / undefined if no projectItem opened
 */
export async function getProjectItemAtSourceMonitor() {
  return ppro.SourceMonitor.getProjectItem();
}

/**
 * open projectItem [clip] in the file user selected
 */
export async function openFilePath() {
  // @ts-ignore
  const file = await uxp.storage.localFileSystem.getFileForOpening();
  if (file?.isFile && file.nativePath) {
    return ppro.SourceMonitor.openFilePath(file.nativePath);
  }
}

/**
 * open open user selected projectItem in source monitor
 * @param selected Name of selected ProjectItem
 * @returns [Boolean] if open projectItem at source monitor succeed
 */
export async function openProjectItem(selected: string) {
  let success = false;
  const proj = await ppro.Project.getActiveProject();
  if (!proj) {
    log(`Load projectItems failed. Cannot find active project.`);
    return;
  }
  const projectRootItem = await proj.getRootItem();
  let projectItems: Array<ProjectItem> = await projectRootItem.getItems();
  if (!projectItems) {
    log(`Project Empty. Cannot find valid projectItem to open`);
    return;
  }

  for (let i = 0; i < projectItems.length; i++) {
    // open projectItem with corresponding name
    if (projectItems[i].name == selected) {
      success = await ppro.SourceMonitor.openProjectItem(projectItems[i]);
    }
  }
  return success;
}

/**
 * play clip at source monitor in original speed
 */
export async function play() {
  return ppro.SourceMonitor.play(1.0);
}

/**
 * get time cursor position at source monitor
 * @returns [Ticktime Object] current time of source monitor cursor
 */
export async function getPosition() {
  return await ppro.SourceMonitor.getPosition();
}

/**
 * close current active clip at source monitor
 */
export async function closeClip() {
  return ppro.SourceMonitor.closeClip();
}

/**
 * close all clips at source monitor
 */
export async function closeAllClips() {
  return ppro.SourceMonitor.closeAllClips();
}
```

## File: html/src/transition.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

import type { premierepro, Project, Sequence } from "../types.d.ts";
const ppro = require("premierepro") as premierepro;
import { log } from "./utils";

let trackItems;
let matchnames;
const transitionFactory = ppro.TransitionFactory;

export async function getVideoTrackItems() {
  let proj = await ppro.Project.getActiveProject();
  if (!proj) {
    log(`No project found.`, "red");
    return;
  } else {
    let sequence = await proj.getActiveSequence();
    if (!sequence) {
      log("No sequence found", "red");
      return;
    } else {
      let videoTrack = await sequence.getVideoTrack(0);
      if (!videoTrack) {
        log("No videoTrack found", "red");
        return;
      } else {
        trackItems = await videoTrack.getTrackItems(
          ppro.Constants.TrackItemType.CLIP,
          false
        );
        if (trackItems.length == 0) {
          log("No trackItems found", "red");
          return;
        }
      }
    }
  }
  return trackItems;
}

//Gets all the transition matchNames.
export async function getTransitionNames() {
  return await transitionFactory.getVideoTransitionMatchNames();
}

export async function addTransitionStart(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const videoTrackItems = await getVideoTrackItems();

  if (videoTrackItems && videoTrackItems.length === 0) {
    return;
  }
  matchnames = await transitionFactory.getVideoTransitionMatchNames();

  let addTransitionOptions = ppro.AddTransitionOptions();
  addTransitionOptions.setApplyToStart(true);

  const videoTransition = await transitionFactory.createVideoTransition(
    matchnames[0]
  );

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        var action1 = videoTrackItems[0].createAddVideoTransitionAction(
          videoTransition,
          addTransitionOptions
        );
        compoundAction.addAction(action1);
      }, "createAddTransitionAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function addTransitionEnd(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const videoTrackItems = await getVideoTrackItems();

  if (videoTrackItems && videoTrackItems.length === 0) {
    return;
  }

  matchnames = await transitionFactory.getVideoTransitionMatchNames();
  const videoTransition = await transitionFactory.createVideoTransition(
    matchnames[1]
  );

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        var action1 =
          videoTrackItems[0].createAddVideoTransitionAction(videoTransition);
        compoundAction.addAction(action1);
      }, "createAddTransitionAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}

export async function removeTransitionStart(project: Project) {
  if (!project) {
    log(`No project found.`, "red");
    return;
  }
  const videoTrackItems = await getVideoTrackItems();

  if (videoTrackItems && videoTrackItems.length === 0) {
    return;
  }

  let success = false;
  try {
    project.lockedAccess(() => {
      success = project.executeTransaction((compoundAction) => {
        var action1 = videoTrackItems[0].createRemoveVideoTransitionAction(
          ppro.Constants.TransitionPosition.START
        );
        compoundAction.addAction(action1);
      }, "createRemoveVideoTransitionAction");
    });
  } catch (err) {
    log(`Error: ${err}`, "red");
    return false;
  }

  return success;
}
```

## File: html/src/utils.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/

export const log = (msg: string, color?: string) => {
  const console = document.querySelector("#plugin-body");
  console.innerHTML += color
    ? `<span style='color:${color}'>${msg}</span><br />`
    : `${msg}<br />`;

  console.scrollTop = console.scrollHeight;
};

export const clearLog = () =>
  (document.querySelector("#plugin-body").innerHTML = "");

export const registerClick = (id: string, cb: Function) => {
  //@ts-ignore
  document.querySelector(`#${id}`).addEventListener("click", cb);
};
```

## File: html/index.html
```html
<!DOCTYPE html>
<html>
  <head>
    <script src="index.js"></script>
  </head>
  <style>
    body {
      color: white;
      padding: 0 16px;
      overflow-y: auto;
      height: 100vh;
    }

    li:before {
      content: " ";
      width: 3em;
    }

    #plugin-body {
      color: var(--uxp-host-text-color-secondary, white);
      margin-top: 5px;
      border: 1px solid #808080;
      border-radius: 4px;
      padding: 16px;
      overflow: scroll;
      height: 220px;
    }

    sp-heading {
      color: var(--uxp-host-text-color-secondary, white);
    }

    footer {
      display: flex;
      flex-wrap: wrap;
      justify-content: flex-start;
      margin-top: 300px;
    }

    footer > * {
      margin-bottom: 10px;
    }

    sp-button {
      height: 20px;
      border-radius: 0.5em;
      font-size: 1.1em;
    }

    #ae-component-name {
      height: 20px;
      border-radius: 0.5em;
      font-size: 1.1em;
      margin: 0;
    }

    h4 {
      margin-top: 0.5em;
      margin-bottom: 0.5em;
    }

    footer div {
      width: 100%;
      margin-bottom: 1em;
    }

    #project-items {
      margin: 0;
      height: 20px;
      width: 50%;
    }

    .main-div {
      position: relative;
    }

    .clear-btn {
      display: none;
      position: absolute;
      top: 10px;
      right: 6px;
      cursor: pointer;
    }

    .main-div:hover .clear-btn {
      display: inline;
    }

    .title-heading {
      padding-top: 5px;
      padding-bottom: 15px;
    }

    .fixed {
      position: fixed;
      top: 0;
      width: calc(100% - 32px);
      background-color: #222;
      z-index: 1000;
      margin-right: 20px;
    }
  </style>

  <body>
    <div class="fixed">
      <h4>Console</h4>
      <div class="main-div">
        <sp-body id="plugin-body"> Ready <br /></sp-body>
        <div class="clear-btn" title="Clear console">
          <sp-icon name="ui:CrossSmall"></sp-icon>
        </div>
      </div>
      <div class="title-heading">
        <h5>
          Active Project:
          <span id="active-project-name">No Active Project</span>
        </h5>
        <h5>
          Active Sequence:
          <span id="active-sequence-name">No Active Sequence</span>
        </h5>
      </div>
    </div>
    <footer>
      <div class="section">
        <h4>Project</h4>
        <sp-button id="open-project">Open Project</sp-button>
        <sp-button id="active-project">Active Project</sp-button>
        <sp-button id="active-sequence-project">Active Sequence</sp-button>
        <sp-button id="open-from-id-project">Project From Id</sp-button>
        <sp-button id="get-insertion-bin-project">Get Insertion Bin</sp-button>
        <sp-button id="get-all-sequences-project">Get All Sequences</sp-button>
        <sp-button id="open-sequence-project">Open Sequence</sp-button>
        <sp-button id="pause-project">Pause Growing</sp-button>
        <sp-button id="save-project">Save Project</sp-button>
        <sp-button id="save-as-project">Save As Project</sp-button>
        <sp-button id="get-supported-luminances-project"
          >Get Supported Graphics White Luminances</sp-button
        >
        <sp-button id="get-luminance-project"
          >Get Current Graphics White Luminance</sp-button
        >
        <sp-button id="close-project">Close Project</sp-button>
      </div>
      <div class="section">
        <h4>Sequence</h4>
        <sp-button id="get-sequence-settings"
          >Get Sequence Video Settings Infos</sp-button
        >
        <sp-button id="set-sequence-settings"
          >Set Sequence Pixel Aspect Ratio</sp-button
        >
        <sp-button id="set-sequence-in-out-point"
          >Set Sequence In and Out Point</sp-button
        >
        <sp-button id="get-sequence-from-id">Get Sequence From Id</sp-button>
        <sp-button id="set-active-sequence">Set Last Sequence Active</sp-button>
        <sp-button id="create-sequence">Create Sequence</sp-button>
        <sp-button id="create-media-sequence"
          >Create Sequence From Media</sp-button
        >
        <sp-button id="get-caption-track-count"
          >Get Caption Track Count</sp-button
        >
        <sp-button id="get-video-track-sequence"
          >Get First Video Track</sp-button
        >
        <sp-button id="get-selection-sequence"
          >Get Sequence Selection</sp-button
        >
        <sp-button id="set-selection-sequence"
          >Set Sequence Selection</sp-button
        >
        <sp-button id="create-sub-sequence">Create Subsequence</sp-button>
        <sp-button id="overwrite-item"
          >Overwrite TrackItem with Selected ProjectItem</sp-button
        >
        <sp-button id="insert-item"
          >Insert TrackItem with Selected ProjectItem</sp-button
        >
        <sp-button id="insert-mogrt">Insert Mogrt from Path at V2</sp-button>
        <sp-button id="clone-selected-item"
          >Clone Selected TrackItem to Another Track</sp-button
        >
        <sp-button id="remove-selected-items"
          >Remove Selected TrackItems</sp-button
        >
        <sp-button id="trim-selected-item">
          Trim First Selected TrackItem
        </sp-button>
        <sp-button id="trim-handles">
          Trim 20 Frames Off Head and Tail of First Selected TrackItem
        </sp-button>
        <sp-button id="rename-first-selected-trackItem">
          Rename First Selected TrackItem
        </sp-button>
      </div>
      <div class="section">
        <h4>Markers</h4>
        <sp-button id="marker-comment">Add Comment Marker</sp-button>
        <sp-button id="marker-chapter">Add Chapter Marker</sp-button>
        <sp-button id="marker-weblink">Add Weblink Marker</sp-button>
        <sp-button id="marker-flashcuepoint"
          >Add Flash Cue Point Marker</sp-button
        >
        <sp-button id="marker-movemarker">Move Marker</sp-button>
        <sp-button id="marker-removemarker">Remove Marker</sp-button>
        <sp-button id="marker-info-sequence"
          >Get Sequence Marker Info</sp-button
        >
      </div>
      <div class="section">
        <h4>Project Panel Item Manipulation</h4>
        <sp-button id="get-project-items"> Get Project Items</sp-button>
        <sp-button id="get-selected-project-items">
          Get Selected Project Items</sp-button
        >
        <sp-button id="get-media-path"> Get Media File Path</sp-button>
        <sp-button id="get-media-info"> Get Media Info</sp-button>
        <sp-button id="set-media-start">
          Set Media Start to 1 second
        </sp-button>
        <sp-button id="create-bin"> Create Bin</sp-button>
        <sp-button id="create-smart-bin"> Create Smart Bin</sp-button>
        <sp-button id="rename-bin"> Rename Bin</sp-button>
        <sp-button id="remove-item"> Remove Item</sp-button>
        <sp-button id="move-item"> Move Item</sp-button>
        <sp-button id="set-in-out-point"> Set In Out Point</sp-button>
        <sp-button id="clear-in-out-point"> Clear In Out Point</sp-button>
        <sp-button id="set-override-framerate">
          Set Override FrameRate</sp-button
        >
        <sp-button id="set-override-pixel-aspect-ratio">
          Set Override Pixel Aspect Ratio</sp-button
        >
        <sp-button id="set-scale-to-frame-size">
          Set Scale To Frame Size</sp-button
        >
        <sp-button id="set-footage-interpretation">
          Set Footage Interpretation</sp-button
        >
        <sp-button id="refresh-media"> Refresh Media</sp-button>
        <sp-button id="attach-proxy"> Attach Proxy</sp-button>
        <sp-button id="change-path"> Change Media File Path</sp-button>
        <sp-button id="get-view-ids"> Get Project View Ids</sp-button>
        <sp-button id="get-project-from-view-id">
          Get Project From First View Id</sp-button
        >
        <sp-button id="get-selection-from-view-id">
          Get Selected ProjectItems From First View Id</sp-button
        >
        <sp-button id="rename-first-selected-projectItem">
          Rename First Selected ProjectItem
        </sp-button>
      </div>
      <div class="section">
        <h4>Metadata</h4>
        <sp-button id="get-project-metadata">Get Project MetaData</sp-button>
        <sp-button id="get-xmp-metadata">Get XMP MetaData</sp-button>
        <sp-button id="get-projectcolumns-metadata"
          >Get Project Columns MetaData</sp-button
        >
        <sp-button id="get-projectpanel-metadata"
          >Get Project Panel MetaData</sp-button
        >
        <sp-button id="set-project-metadata">Set Project Metadata</sp-button>
        <sp-button id="set-xmp-metadata">Set XMP Metadata</sp-button>
        <sp-button id="set-projectpanel-metadata"
          >Set Project Panel MetaData</sp-button
        >
        <sp-button id="add-property-metadata-schema"
          >Add Property To Project Metdata Schema</sp-button
        >
      </div>
      <div class="section">
        <h4>Source Monitor Controls</h4>
        <sp-button id="open-projectItem">Open ProjectItem</sp-button>
        <select id="project-items"></select>

        <sp-button id="open-filePath">Open File Path</sp-button>
        <sp-button id="play">Play</sp-button>
        <sp-button id="get-pos">Get Position</sp-button>
        <sp-button id="close-clip">Close Clip</sp-button>
        <sp-button id="close-all-clips">Close All Clips</sp-button>
      </div>
      <div class="section">
        <h4>Keyframe</h4>
        <sp-button id="set-value">Set Value </sp-button>
        <sp-button id="get-start-value">Get Start Value</sp-button>
        <sp-button id="add-keyframe">Add Keyframe</sp-button>
        <sp-button id="get-keyframes">Get Keyframes As Ticktime</sp-button>
        <sp-button id="get-keyfram-time">Get Keyframes At Time</sp-button>
        <sp-button id="set-interpolation"
          >Set Interpolation At Keyframe</sp-button
        >
      </div>
      <div class="section">
        <h4>Effects & Transitions</h4>
        <sp-button id="get-effect-names">Get Effect Names</sp-button>
        <sp-button id="add-gamma-correction-effect"
          >Add Gamma Correction Effect</sp-button
        >
        <sp-button id="add-multiple-effects"
          >Add Gamma Correction and Extract Effect</sp-button
        >
        <sp-button id="add-vocal-enhancer-effect"
          >Add Vocal Enhancer Effect</sp-button
        >
        <sp-button id="remove-gamma-correction-effect"
          >Remove The Last Effect</sp-button
        >
        <sp-button id="get-transition-names">Get Transition Names</sp-button>
        <sp-button id="add-transition-start"
          >Add Transition To The Start Of TrackItem</sp-button
        >
        <sp-button id="add-transition-end"
          >Add Transition To The End Of TrackItem</sp-button
        >
        <sp-button id="remove-transition-start"
          >Remove Transition To The Start</sp-button
        >
      </div>
      <div class="section">
        <h4>Properties</h4>
        <sp-button id="get-sequence-property"
          >Get Sample Sequence Property</sp-button
        >
        <sp-button id="set-sequence-property"
          >Set New Sample Sequence Property</sp-button
        >
        <sp-button id="clear-sequence-property"
          >Clear New Sample Sequence Property</sp-button
        >
      </div>
      <div class="section">
        <h4>Settings</h4>
        <sp-button id="get-project-setting"
          >Get Scratch Disk Path Setting</sp-button
        >
        <sp-button id="set-project-setting"
          >Set Scratch Disk Path Setting To MyDocuments</sp-button
        >
        <sp-button id="get-ingest-setting">Get Ingest Enabled</sp-button>
        <sp-button id="set-ingest-enabled">Set Ingest Enabled</sp-button>
      </div>
      <div class="section">
        <h4>App Preference</h4>
        <sp-button id="get-autopeak-preference"
          >Get Auto Peak Generation Preference
        </sp-button>
        <sp-button id="set-autopeak-setting"
          >Toggle Auto Peak Generation Preference</sp-button
        >
      </div>
      <div class="section">
        <h4>Export Controls</h4>
        <sp-button id="export-frame"> Export Current Frame As PNG </sp-button>
        <sp-button id="export-sequence">
          Export Sequence Using Preset
        </sp-button>
        <sp-button id="get-export-file-extension">
          Get Exported File Extension From .epr
        </sp-button>
      </div>
      <div class="section">
        <h4>Import Controls</h4>
        <sp-button id="import-ae-component">Import AE Composition</sp-button>
        <input
          type="text"
          id="ae-component-name"
          placeholder="AE Composition Name Here"
        />
        <sp-button id="import-files">Import Media Files From Disk</sp-button>
        <sp-button id="import-all-ae-components"
          >Import All AE Composition</sp-button
        >
        <sp-button id="import-sequences">Import Sequences From Disk</sp-button>
      </div>
    </footer>
  </body>
</html>
```

## File: html/index.ts
```typescript
/*************************************************************************
 * ADOBE CONFIDENTIAL
 * ___________________
 *
 * Copyright 2024 Adobe
 * All Rights Reserved.
 *
 * NOTICE: Adobe permits you to use, modify, and distribute this file in
 * accordance with the terms of the Adobe license agreement accompanying
 * it. If you have received this file from a source other than Adobe,
 * then your use, modification, or distribution of it requires the prior
 * written permission of Adobe.
 **************************************************************************/
/// <reference path="./types.d.ts" />
//module imports
import { log, clearLog, registerClick } from "./src/utils";
import {
  openProject,
  openInputProject,
  getActiveProject,
  getActiveSequence,
  getProjectFromId,
  getInsertionBin,
  getAllSequences,
  openSequence,
  pauseGrowing,
  saveProject,
  saveAsProject,
  getSupportedGraphicsWhiteLuminances,
  getCurrentGraphicsWhiteLuminance,
  closeProject,
} from "./src/project";

import {
  getSequence,
  setActiveSequence,
  createSequence,
  createSequenceFromMedia,
  getCaptionTrackCount,
  getVideoTrack,
  getSequenceSelection,
  setSequenceSelection,
  createSubsequence,
  trimSelectedItem,
  addHandlesToTrackItem,
  getVideoSettingsInfo,
  setSequencePixelAsepctRatio,
  setSequenceInOutPoint,
  renameFirstSelectedTrackItem,
} from "./src/sequence";

import {
  createMarkerComment,
  createMarkerChapter,
  createMarkerWeblink,
  createMarkerFlashCuePoint,
  moveMarker,
  removeMarker,
  getSequenceMarkerInfo,
} from "./src/markers";
import {
  getProjectItems,
  getSelectedProjectItems,
  getMediaFilePath,
  createBin,
  createSmartBin,
  renameBin,
  removeItem,
  moveItem,
  setInOutPoint,
  clearInOutPoint,
  setScaleToFrameSize,
  refreshMedia,
  setFootageInterpretation,
  setOverrideFrameRate,
  setOverridePixelAspectRatio,
  attachProxy,
  changeMediaFilePath,
  getProjectViewIds,
  getProjectFromViewId,
  getSelectedProjectItemsFromViewId,
  renameFirstSelectedProjectItem,
  getMediaInfo,
  setMediaStart,
} from "./src/projectPanel";

import {
  addPropertiesToMetadataSchema,
  setProjectPanelMetadata,
  setProjectMetadata,
  setXMPMetadata,
  getProjectPanelMetadata,
  getProjectMetadata,
  getXMPMetadata,
  getProjectColumnsMetadata,
} from "./src/metadata";

import {
  getProjectItemAtSourceMonitor,
  openFilePath,
  openProjectItem,
  play,
  getPosition,
  closeClip,
  closeAllClips,
} from "./src/sourceMonitor";

import {
  setValue,
  getStartValue,
  addKeyframe,
  getKeyframes,
  getKeyframe,
  setInterpolation,
} from "./src/keyframe";

import {
  getEffectsName,
  addEffects,
  addMultipleEffects,
  removeEffects,
  addVocalEnhancerEffect,
} from "./src/effects";

import {
  getTransitionNames,
  addTransitionStart,
  addTransitionEnd,
  removeTransitionStart,
} from "./src/transition";

import {
  getSequenceSampleProperty,
  setSampleSequenceProperty,
  clearSampleSequenceProperty,
} from "./src/properties";

import {
  getScratchDiskSetting,
  setScratchDiskSettings,
  getIngestEnabled,
  setIngestEnabled,
} from "./src/settings";

import { addProjSeqListeners, addEncoderListeners } from "./src/eventManager";

import {
  exportSequenceFrame,
  exportSequence,
  getExportFileExtension,
} from "./src/export";

import {
  importFiles,
  importSequences,
  importAeComponent,
  importAllAeComponents,
} from "./src/import";

import {
  getPreferenceSetting,
  setPreferenceSetting,
} from "./src/appPreference";

import {
  overwriteTrackItem,
  insertTrackItem,
  insertMogrt,
  cloneSelectedTrackItem,
  removeSelectedTrackItems,
} from "./src/sequenceEditor";

//global objects.
import type {
  premierepro,
  ProjectItem,
  Guid,
  Sequence,
  VideoClipTrackItem,
  AudioClipTrackItem,
} from "./types.d.ts";
const ppro = require("premierepro") as premierepro;
const uxp = require("uxp") as typeof import("uxp");

//project button events
async function openProjectClicked() {
  const project = await openProject();
  if (project) {
    log(`Project "${project.name} opened successfully`);
  } else {
    log(`Failed to open the project`, "red");
  }
}

async function getActiveProjectClicked() {
  const activeProject = await getActiveProject();
  if (activeProject) {
    log(`Active project is "${activeProject.name}"`);
  } else {
    log(`Failed to find active project`, "red");
  }
}

async function getActiveSequenceClicked() {
  const project = await getProject();
  if (!project) return;

  const activeSequence = await getActiveSequence(project);
  if (activeSequence) {
    log(`Active sequence is "${activeSequence.name}"`);
  } else {
    log(`Failed to find active sequence`, "red");
  }
}

async function getProjectFromIdClicked() {
  const baseProject = await getProject();
  const projectId = baseProject.guid;

  const project = await getProjectFromId(projectId);
  if (project) {
    log(`Project is "${project.name}" for the projectid: ${projectId}`);
  } else {
    log(`Failed to find the project for the id ${projectId}`, "red");
  }
}

async function getInsertionBinClicked() {
  const project = await getProject();
  if (!project) return;

  const folder = await getInsertionBin(project);
  if (folder) {
    log(`Folder name is "${folder.name}"`);
  } else {
    log(`No folder found`, "red");
  }
}

async function getAllSequencesClicked() {
  const project = await getProject();
  if (!project) return;

  const sequences: Array<Sequence> = await getAllSequences(project);
  if (sequences.length === 0) {
    log("No sequences found.", "red");
  } else {
    log("Sequences are: ");
    sequences.forEach((sequence, index) => {
      log(`${index + 1}. Sequence ${sequence.name}`);
    });
  }
}

async function openSequenceClicked() {
  const project = await getProject();
  if (!project) return;

  const sequences = await getAllSequences(project);
  if (sequences.length === 0) {
    log("No sequences found.", "red");
    return;
  }
  if (sequences.length === 1) {
    log(
      `Please have at least 2 sequences for this project ${project.name}.`,
      "orange"
    );
    return;
  }
  const activeSequence: Sequence = await getActiveSequence(project);
  if (!activeSequence) {
    log(`Failed to find active sequence`, "red");
    return;
  }

  const proposedSequence: Sequence = sequences.find(
    (seq: Sequence) => seq.name != activeSequence.name
  );

  if (!proposedSequence) {
    log(`Failed to find the proposed sequence`, "red");
    return;
  }

  log(`Trying to open sequence ${proposedSequence.name}`);

  const success = await openSequence(project, proposedSequence);
  if (!success) {
    log(`Open sequence ${proposedSequence.name} failed`, "red");
    return;
  }

  const newActiveSequence = await getActiveSequence(project);
  log(
    newActiveSequence && proposedSequence.name === newActiveSequence.name
      ? `Sequence ${newActiveSequence.name} opened`
      : `Failed to open ${newActiveSequence.name}`
  );
}

//Can also be used to unpause by passing false.
async function pauseGrowingClicked() {
  const project = await getProject();
  if (!project) return;

  let success = await pauseGrowing(true, project);
  log(
    success
      ? `Stopped the project file (${project.name}) from growing further to prevent it from becoming too large, and switched to a new file.`
      : `Failed to pause file growing for project ${project.name}`
  );
}

async function saveProjectClicked() {
  const project = await getProject();
  if (!project) return;

  let success = await saveProject(project);
  log(
    success
      ? `Project ${project.name} successfully`
      : `Failed to save project ${project.name}`
  );
}

async function saveAsProjectClicked() {
  const project = await getProject();
  if (!project) return;

  let success = await saveAsProject(project);
  log(
    success
      ? `Project ${project.name} saved as successfully`
      : `Failed to do save as project ${project.name}`
  );
}

async function getSupportedGraphicsWhiteLuminancesClicked() {
  const project = await getProject();
  if (!project) return;

  let supportedColors = await getSupportedGraphicsWhiteLuminances(project);
  if (supportedColors.length === 0) {
    log("No supported colors found.", "red");
    return;
  }

  supportedColors.forEach((color, index) => {
    log(`${index + 1}. Color: ${color}`);
  });
}

async function getCurrentGraphicsWhiteLuminanceClicked() {
  const project = await getProject();
  if (!project) return;

  const color = await getCurrentGraphicsWhiteLuminance(project);
  log(
    color
      ? `Current white luminance value: ${color}`
      : "No white luminance value found"
  );
}

async function closeProjectClicked() {
  const project = await getProject();
  if (!project) return;

  const projName = project.name;
  await closeProject(project);
  log(`Project "${projName}" is closed.`);
}

//sequence button events
async function getSequenceSettingsClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  if (!sequence) {
    log(`No sequences found`);
    return;
  }

  const sequenceVideoSettingsInfo = await getVideoSettingsInfo(sequence);
  for (let info of sequenceVideoSettingsInfo) {
    log(info);
  }
}

async function setSequencePixelAspectRatioClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  if (!sequence) {
    log(`No sequences found`);
    return;
  }
  const success = await setSequencePixelAsepctRatio(project, sequence);
  log(
    success
      ? `Sequence ${sequence.name} pixel aspect ratio changed to Square`
      : `Failed to set pixel asepct ratio of ${sequence.name}`
  );
}

async function setSequenceInOutPointClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  if (!sequence) {
    log(`No sequences found`);
    return;
  }
  const success = await setSequenceInOutPoint(project, sequence);
  log(
    success
      ? `Sequence ${sequence.name} in out point set successfully`
      : `Failed to set in out point for ${sequence.name}`
  );
}

async function getSequenceClicked() {
  const project = await getProject();
  if (!project) return;

  //Finding the last sequence id
  let sequenceGuid: Guid;
  const sequences = await getAllSequences(project);
  sequences.forEach((sequence: Sequence) => {
    sequenceGuid = sequence.guid;
  });

  if (!sequenceGuid) {
    log(`No sequences found`);
    return;
  }

  log(`Trying to get sequence from sequence id ${sequenceGuid.toString()}`);

  const sequence = await getSequence(project, sequenceGuid);
  log(
    sequence
      ? `Sequence ${sequence.name} found`
      : `No sequence found for id ${sequenceGuid.toString()}`
  );
}

async function setActiveSequenceClicked() {
  const project = await getProject();
  if (!project) return;

  //Finding the last sequence id
  let proposedSequence;
  const sequences = await getAllSequences(project);
  sequences.forEach((sequence) => {
    proposedSequence = sequence;
  });

  if (!proposedSequence) {
    log(`No sequences found to set active sequence`);
    return;
  }

  log(
    `Trying to set active sequence from last sequence ${proposedSequence.name}`
  );

  const success = await setActiveSequence(project, proposedSequence);
  log(
    success
      ? `Set active sequence to "${proposedSequence.name}" (last sequence found)`
      : `Error setting active sequence for id ${proposedSequence.name}`
  );
}

async function createSequenceClicked() {
  const project = await getProject();
  if (!project) return;

  const sequenceName = `Sequence-${new Date().toLocaleString()}`;
  const sequence = await createSequence(project, sequenceName);
  log(
    sequence
      ? `Sequence ${sequence.name} created successfully`
      : `Error creating sequence`
  );
}

async function createSequenceFromMediaClicked() {
  const project = await getProject();
  if (!project) return;

  const sequenceName = `Sequence-${new Date().toLocaleString()}`;
  const sequence = await createSequenceFromMedia(project, sequenceName);
  log(
    sequence
      ? `Sequence ${sequence.name} created successfully`
      : `Error creating sequence`
  );
}

async function getCaptionTrackCountClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  const captionTrackCount = await getCaptionTrackCount(sequence);
  log(
    captionTrackCount > 0
      ? `Number of caption tracks found: ${captionTrackCount}`
      : `No caption tracks found`
  );
}

async function getVideoTrackClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  const videoTrack = await getVideoTrack(sequence, 0);
  log(
    videoTrack
      ? `First video track found: "${videoTrack.name}"`
      : `No video track found`
  );
}

async function getSequenceSelectionClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  let trackItemSelection = await getSequenceSelection(sequence);
  let trackItems = await trackItemSelection.getTrackItems();
  if (!trackItems.length) {
    log("No track items selected", "red");
    return;
  }
  log(`Selected TrackItems:\n`);
  trackItems.forEach(
    async (item: VideoClipTrackItem | AudioClipTrackItem, index) => {
      let name = await item.getName();
      log(`    ${index + 1}: ${name}\n`);
    }
  );
}

async function setSequenceSelectionClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  let success = await setSequenceSelection(sequence);
  log(
    success
      ? `Successfully set the selection for sequence ${sequence.name}`
      : `Could not set selection for sequence ${sequence.name}`
  );
}

async function createSubsequenceClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  let newSequence = await createSubsequence(sequence);
  log(
    newSequence
      ? `Sub sequence created with ${newSequence.name}`
      : `Could not create sub sequence`
  );
}

async function overwriteItemClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await overwriteTrackItem(project);
  log(
    success
      ? "New trackItem overwrote item at V2/A2 of active sequence"
      : "Failed to overwrite trackItem in active sequence"
  );
}

async function insertItemClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await insertTrackItem(project);
  log(
    success
      ? "New trackItem is inserted at V2/A2 of active sequence"
      : "Failed to insert trackItem in active sequence"
  );
}

async function insertMogrtClicked() {
  const project = await getProject();
  if (!project) return;
  let mogrtPath;
  // @ts-ignore
  const file = await uxp.storage.localFileSystem.getFileForOpening({
    types: ["mogrt"],
  });
  if (file?.isFile && file.nativePath) {
    mogrtPath = file.nativePath;
  } else {
    log("Selection of file failed. Please try again");
    return;
  }
  const success = await insertMogrt(project, mogrtPath);
  log(
    success
      ? "New mogrt item inserted at V2/A2 of active sequence"
      : "Failed to insert trackItem in active sequence"
  );
}

async function cloneSelectedItemClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await cloneSelectedTrackItem(project);
  log(
    success
      ? "Selected trackItem is cloned at track of active sequence"
      : "Failed to clone the trackItem in active sequence"
  );
}

async function removeSelectedItemClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await removeSelectedTrackItems(project);
  log(
    success
      ? "Selected trackItems are removed at active sequence"
      : "Failed to remove selected trackItems at active sequence"
  );
}

async function trimSelectedItemClicked() {
  const project = await getProject();
  const sequence = await getActiveSequence(project);
  if (!project) return;

  const success = await trimSelectedItem(project, sequence);
  log(
    success
      ? "First selected trackItem is trimmed and shortened by 1s"
      : "Failed to trim selected trackItem at active sequence"
  );
}

async function trimHandlesClicked(callback) {
  let success = false;
  const project = await getProject();
  if (!project) return;

  const sequence = await getActiveSequence(project);
  if (!sequence) return;

  const selection = await sequence.getSelection();
  const items: Array<VideoClipTrackItem | AudioClipTrackItem> =
    await selection.getTrackItems();

  const inPointOffset = -20;
  const outPointOffset = -20;
  if (items.length > 0) {
    const trackItemToChange = items[0];
    success = await addHandlesToTrackItem(
      project,
      sequence,
      trackItemToChange,
      inPointOffset,
      outPointOffset
    );
  } else {
    log("No trackItem selected.", "red");
    throw new Error("no trackItem is selected at sequence");
  }

  if (success) {
    log(
      `First trackItem handles were changed by ${inPointOffset} frame(s) at head and ${outPointOffset} frame(s) at the tail.`
    );
  } else {
    log("Failed to trim first selected trackItem.", "red");
  }
}

async function renameFirstSelectedTrackItemClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await getActiveSequence(project);
  if (!sequence) {
    log("No sequences found");
  }
  const success = await renameFirstSelectedTrackItem(project, sequence);
  log(
    success
      ? "Successfully renamed first selected trackItem to TrackItem 1"
      : "Failed to rename trackItem"
  );
}

//marker button events
async function createMarkerCommentClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await createMarkerComment(project);
  log(
    success ? "Add comment marker successfull" : "Failed to add comment marker"
  );
}

async function createMarkerChapterClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await createMarkerChapter(project);
  log(
    success ? "Add chapter marker successfull" : "Failed to add chapter marker"
  );
}

async function createMarkerWeblinkClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await createMarkerWeblink(project);
  log(
    success ? "Add weblink marker successfull" : "Failed to add weblink marker"
  );
}

async function createMarkerFlashCuePointClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await createMarkerFlashCuePoint(project);
  log(
    success
      ? "Add flash cue point marker successfull"
      : "Failed to add flash cue point marker"
  );
}

async function moveMarkerClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await moveMarker(project);
  log(success ? "Move marker successfull" : "Failed to move marker");
}

async function removeMarkerClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await removeMarker(project);
  log(success ? "Remove marker successfull" : "Failed to remove marker");
}

async function getSequenceMarkerInfoClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await project.getActiveSequence();
  if (!sequence) {
    log("No sequences found");
    return;
  }

  const sequenceMarkerInfos = await getSequenceMarkerInfo(sequence);
  if (sequenceMarkerInfos.length == 0) {
    log("No sequence markers found");
    return;
  }
  for (const [index, markerInfo] of sequenceMarkerInfos.entries()) {
    log(`${index + 1}.`);
    log(`Marker Name: ${markerInfo.name}`);
    log(`Marker Type: ${markerInfo.type}`);
    log(
      `Marker Color: RGBA(${markerInfo.color.red}, ${markerInfo.color.green}, ${markerInfo.color.blue}, ${markerInfo.color.alpha})`
    );
  }
}

async function getProjectItemsClicked() {
  const project = await getProject();
  if (!project) return;

  const projectItems: Array<ProjectItem> = await getProjectItems(project);
  if (!projectItems.length) {
    log("No project items found", "red");
    return;
  }
  log("Project Item read is successfull");
  projectItems.forEach((item, index) => {
    log(`   ${index + 1}: ${item.name}`);
  });
}

async function getSelectedProjectItemsClicked() {
  const project = await getProject();
  if (!project) return;

  const projectItems: Array<ProjectItem> = await getSelectedProjectItems(
    project
  );
  if (!projectItems.length) {
    log("No project items found", "red");
    return;
  }
  log("Project Item read is successfull");
  projectItems.forEach((item, index) => {
    log(`   ${index + 1}: ${item.name}`);
  });
}

async function getMediaFilePathClicked() {
  const project = await getProject();
  if (!project) return;

  const path = await getMediaFilePath(project);
  if (path == null) {
    log("No media project item available for getting path");
  } else {
    log(`Path of project item is ${path}`);
  }
}

async function createBinClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await createBin(project);
  if (!success) {
    log("Failed to create Bin", "red");
    return;
  }
  log("Successfully created a new bin");
}

async function createSmartBinClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await createSmartBin(project);
  if (!success) {
    log("Failed to create smart Bin", "red");
    return;
  }
  log("Successfully created a new smart bin");
}

async function renameBinClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await renameBin(project);
  if (!success) {
    log("Failed to rename Bin", "red");
    return;
  }
  log("Successfully renamed the bin");
}

async function removeItemClicked() {
  const project = await getProject();
  if (!project) return;

  await removeItem(project);
}

async function moveItemClicked() {
  const project = await getProject();
  if (!project) return;

  await moveItem(project);
}

async function setInOutPointClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await setInOutPoint(project);
  if (!success) {
    log("Failed to set In Out Points", "red");
    return;
  }
  log("Successfully set In Out points");
}

async function clearInOutPointClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await clearInOutPoint(project);
  if (!success) {
    log("Failed to clear In Out Points", "red");
    return;
  }
  log("Successfully cleared In Out points");
}
async function setScaleToFrameSizeClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await setScaleToFrameSize(project);
  if (!success) {
    log("Failed to set scale to frame size", "red");
    return;
  }
  log("Successfully set scale to frame size");
}

async function refreshMediaClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await refreshMedia(project);
  if (!success) {
    log("Failed to refresh media", "red");
    return;
  }
  log("Successfully refreshed media");
}

async function setFootageInterpretationClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await setFootageInterpretation(project);
  if (!success) {
    log("Failed to set footage interpretation", "red");
    return;
  }
  log("Successfully set footage interpretation");
}

async function attachProxyClicked() {
  const project = await getProject();
  if (!project) return;

  let proxyFile;
  log("Please select media file to attach as proxy");
  // @ts-ignore
  const file = await uxp.storage.localFileSystem.getFileForOpening();
  if (file?.isFile && file.nativePath) {
    proxyFile = file.nativePath;
  } else {
    log("Selection of proxy file failed. Please try again");
    return;
  }

  const success = await attachProxy(project, proxyFile);
  log(
    success
      ? "Successfully attached new proxy to projectItem"
      : "Failed to attach proxy"
  );
}

async function changePathClicked() {
  const project = await getProject();
  if (!project) return;

  let mediaFile;
  log("Please select media file for the change of media file path");
  // @ts-ignore
  const file = await uxp.storage.localFileSystem.getFileForOpening();
  if (file?.isFile && file.nativePath) {
    mediaFile = file.nativePath;
  } else {
    log("Selection of new media file failed. Please try again");
    return;
  }

  const success = await changeMediaFilePath(project, mediaFile);
  log(
    success
      ? "Successfully changed media file path"
      : "Failed to change media file path of projectItem"
  );
}

async function getProjectViewIdsClicked() {
  const viewIds: Array<Guid> = await getProjectViewIds();
  if (viewIds.length == 0) {
    log("No project view available for getting ids", "red");
    return;
  }
  viewIds.forEach((viewGuid, index) => {
    log(`    ${index + 1}: ${viewGuid.toString()}`);
  });
}

async function getProjectFromViewIdClicked() {
  // get project from first view id found
  const viewIds: Array<Guid> = await getProjectViewIds();
  if (viewIds.length == 0) {
    log("No project view found for getting project", "red");
    return;
  }
  const projectViewId = viewIds[0];
  const project = await getProjectFromViewId(projectViewId);
  if (project) {
    log(
      `Project is "${project.name}" for the project view id: ${projectViewId}`
    );
  } else {
    log(`Failed to find the project for the id ${projectViewId}`, "red");
  }
}

async function getSelectionFromViewIdClicked() {
  // get selected projectItems from first view id found
  const viewIds: Array<Guid> = await getProjectViewIds();
  if (viewIds.length == 0) {
    log("No project view found.", "red");
    return;
  }
  const projectViewId = viewIds[0];
  const selectedItems: Array<ProjectItem> =
    await getSelectedProjectItemsFromViewId(projectViewId);
  if (selectedItems.length == 0) {
    log(`No item is selected for project view with id ${projectViewId}`);
    return;
  }
  selectedItems.forEach((item, index) => {
    log(`   ${index + 1}: ${item.name}`);
  });
}

async function renameFirstSelectedProjectItemClicked() {
  const project = await getActiveProject();
  if (!project) {
    return;
  }
  const success = await renameFirstSelectedProjectItem(project);
  log(
    success
      ? "renamed first selected projectItem to Item 1"
      : "failed to rename projectItem"
  );
}

async function getMediaInfoClicked() {
  const project = await getActiveProject();
  if (!project) {
    return;
  }
  const mediaInfo = await getMediaInfo(project);
  if (mediaInfo) {
    log(`ClipProjectItem Name: ${mediaInfo.name}`);
    log(`     Media Start: ${mediaInfo.start}`);
    log(`     Media Duration: ${mediaInfo.duration}`);
  } else {
    log(`Failed to gather Media Info`);
  }
}

async function setMediaStartClicked() {
  const project = await getActiveProject();
  if (!project) {
    return;
  }
  const success = await setMediaStart(project);
  log(
    success
      ? "Successfully set media start to 1 second"
      : "Failed to set media start"
  );
}

//metadata button events
async function getProjectMetadataClicked() {
  const project = await getProject();
  if (!project) return;

  const metadata = await getProjectMetadata(project);
  if (metadata) {
    try {
      await navigator.clipboard.writeText(metadata);
      log(`Project metadata copied to clipboard`);
    } catch {
      log("Failed to copy Project metadata to clipboard", "red");
    }
  } else {
    log("Failed to read Project metadata"), "red";
  }
}

async function getXMPMetadataClicked() {
  const project = await getProject();
  if (!project) return;

  const metadata = await getXMPMetadata(project);
  if (metadata) {
    try {
      await navigator.clipboard.writeText(metadata);
      log(`XMP Metadata copied to clipboard`);
    } catch {
      log("Failed to copy XMP Metadata to clipboard", "red");
    }
  } else {
    log("Failed to read XMP metadata", "red");
  }
}

async function getProjectColumnsMetadataClicked() {
  const project = await getProject();
  if (!project) return;

  const metadata = await getProjectColumnsMetadata(project);
  if (metadata) {
    try {
      await navigator.clipboard.writeText(metadata);
      log(`Project column metadata copied to clipboard`);
    } catch {
      log("Failed to copy Project column Metadata to clipboard", "red");
    }
  } else {
    log("Failed to read Project column metadata", "red");
  }
}

async function getProjectPanelMetadataClicked() {
  const metadata = await getProjectPanelMetadata();
  if (metadata) {
    try {
      await navigator.clipboard.writeText(metadata);
      log(`Project panel metadata copied to clipboard`);
    } catch {
      log("Failed to copy Project panel metadata to clipboard", "red");
    }
  } else {
    log("Failed to read Project panel metadata", "red");
  }
}

async function setXMPMetadataClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await setXMPMetadata(project);
  log(success ? "Successfully set xmp metadata" : "Failed to set xmp metadata");
}

async function setProjectPanelMetadatClicked() {
  const success = await setProjectPanelMetadata();
  log(
    success
      ? "Successfully set project panel metadata"
      : "Failed to set project panel metadata"
  );
}

async function addPropertiesToMetadataSchemaClicked() {
  const success = await addPropertiesToMetadataSchema();
  log(
    success
      ? "Successfully added properties to metadata schema"
      : "Failed to add properties to metadata schema"
  );
}

async function setProjectMetadataClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await setProjectMetadata(project);
  log(
    success
      ? "Successfully set project metadata"
      : "Failed to set project metadata"
  );
}

//source monitor button events
async function openFilePathClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await openFilePath();
  log(
    success
      ? "Successfully opened selected file at source monitor"
      : "Failed to send the projectItems at selected file to source monitor"
  );
}

async function openProjectItemClicked() {
  let selected = (document.getElementById("project-items") as HTMLInputElement)
    ?.value;

  if (!selected) {
    log("Please select a projectItem to open");
  } else {
    let success = await openProjectItem(selected);
    if (success) {
      log(`Opened ${selected} at source monitor successfully`);
    } else {
      log(`Failed to open ${selected} at source monitor`);
    }
  }
}

async function playClicked() {
  //  check if there is a active projectItem opened at source monitor
  const item = await getProjectItemAtSourceMonitor();
  if (!item) {
    log("No projectItem opened in source monitor");
    return;
  }
  const success = await play();
  log(
    success
      ? "Successfully played current projectItem at source monitor"
      : "Failed to play at source monitor"
  );
}

async function getPositionClicked() {
  //  check if there is a active projectItem opened at source monitor
  const item = await getProjectItemAtSourceMonitor();
  if (!item) {
    log("No projectItem opened in source monitor");
    return;
  }
  let time = await getPosition();
  if (time) {
    log(`Current time of source monitor in seconds is ${time.seconds}`);
  } else {
    log(`Failed to get current time of source monitor`, "red");
  }
}

async function closeClipClicked() {
  //  check if there is a active projectItem opened at source monitor
  const item = await getProjectItemAtSourceMonitor();
  if (!item) {
    log("No projectItem opened in source monitor");
    return;
  }
  const success = await closeClip();
  log(
    success
      ? "Successfully closed clip in source monitor"
      : "Failed to close clip"
  );
}

async function closeAllClipsClicked() {
  //  check if there is a active projectItem opened at source monitor
  const item = await getProjectItemAtSourceMonitor();
  if (!item) {
    log("No projectItem opened in source monitor");
    return;
  }
  const success = await closeAllClips();
  log(
    success
      ? "Successfully closed all clips in source monitor"
      : "Failed to close all clips"
  );
}

async function setValueClicked() {
  const success = await setValue();
  log(success ? "Successfully set the value" : "Failed to set the value");
}
async function getStartValueClicked() {
  const startValueKeyframe = await getStartValue();
  log(
    startValueKeyframe
      ? `start value: "${startValueKeyframe.value.value}"`
      : "Failed to get the start value"
  );
}

async function addKeyframeClicked() {
  const startValue = await addKeyframe();
  log(
    startValue
      ? "Successfully added the keyframe"
      : "Failed to add the keyframe"
  );
}

async function getKeyframesClicked() {
  const ticktimes = await getKeyframes();

  if (ticktimes && ticktimes.length > 0) {
    log("keyframes found at following seconds:");
    for (let index in ticktimes) {
      log(`"${ticktimes[index].seconds}"`);
    }
  } else log("Failed to gets all the keyframe or there is no keyframe found");
}

async function getKeyframeClicked() {
  const keyframe = await getKeyframe();
  log(
    keyframe
      ? `keyframe at 0 seconds has value: "${keyframe.value.value}"`
      : "Failed to gets the keyframe at specific time"
  );
}
async function setInterpolationClicked() {
  const success = await setInterpolation();
  log(
    success
      ? "Successfully sets the Interpolation"
      : "Failed to sets the Interpolation"
  );
}
async function getEffectsNameClicked() {
  const effects = await getEffectsName();
  if (effects) {
    log("Followings are the effects list:");
    for (let index in effects) {
      log(effects[index]);
    }
  } else log("Failed to gets all the effect names", "red");
}
async function addEffectsClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await addEffects(project);
  log(success ? "Successfully added the effect" : "Failed to add the effect");
}
async function addMultipleEffectsClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await addMultipleEffects(project);
  log(success ? "Successfully added the effects" : "Failed to add the effect");
}
async function removeEffectsClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await removeEffects(project);
  log(
    success ? "Successfully removed the effect" : "Failed to remove the effect"
  );
}
async function getTransitionNamesClicked() {
  const transitions = await getTransitionNames();
  if (transitions) {
    log("Followings are the transitions list:");
    for (let index in transitions) {
      log(transitions[index]);
    }
  } else {
    log("Failed to gets all the transitions names", "red");
  }
}

async function addTransitionStartClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await addTransitionStart(project);
  log(
    success
      ? "Successfully added transition to the start of trackitem"
      : "Failed to add transition to the start of trackitem"
  );
}

async function addTransitionEndClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await addTransitionEnd(project);
  log(
    success
      ? "Successfully added transition to the end of trackitem"
      : "Failed to add transition to the end of trackitem"
  );
}

async function removeTransitionStartClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await removeTransitionStart(project);
  log(
    success
      ? "Successfully removed transition to the start of trackitem"
      : "Failed to removed transition to the start of trackitem"
  );
}

async function addVocalEnhancerEffectClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await addVocalEnhancerEffect(project);
  log(
    success
      ? "Successfully add vocal enhancer effect to ptrackitem"
      : "Failed to apply vocal enhancer effefct"
  );
}

async function setOverrideFrameRateClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await setOverrideFrameRate(project);
  if (!success) {
    log("Failed to set override frame rate", "red");
    return;
  }
  log("Successfully set override frame rate");
}

async function setOverridePixelAspectRatioClicked() {
  const project = await getProject();
  if (!project) return;

  const success = await setOverridePixelAspectRatio(project);
  if (!success) {
    log("Failed to set override pixel aspect ratio", "red");
    return;
  }
  log("Successfully set override pixel aspect ratio");
}

//Properties button events
async function getSampleSequencePropertyClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await getActiveSequence(project);
  if (!sequence) {
    log("No active sequence available to check properties");
    return;
  }

  const value = await getSequenceSampleProperty(sequence);
  if (value) {
    log(`Sample Property has value ${value}`);
  }
}

async function setSampleSequencePropertyClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await getActiveSequence(project);
  if (!sequence) {
    log("No active sequence available to set properties");
    return;
  }

  const success = await setSampleSequenceProperty(sequence, project);
  log(
    success
      ? "Successfully added sample property to sequence"
      : "Failed to add sample property to sequence"
  );
}

async function clearSampleSequencePropertyClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await getActiveSequence(project);
  if (!sequence) {
    log("No active sequence available to check properties");
    return;
  }

  const success = await clearSampleSequenceProperty(sequence, project);
  log(
    success
      ? "Successfully removed sample property in sequence"
      : "Failed to remove sample property in sequence"
  );
}

//Settings button events
async function getScratchDiskSettingClicked() {
  const project = await getProject();
  if (!project) return;

  let scratchDiskPath = await getScratchDiskSetting(project);
  log(`Current scratch disk path is ${scratchDiskPath}`);
}

async function setScratchDiskSettingsClicked() {
  const project = await getProject();
  if (!project) return;

  let success = await setScratchDiskSettings(project);
  log(
    success
      ? "Successfully updated scratch disk path to MyDocuments"
      : "Failed to update scratch disk path settings"
  );
}

async function getIngestSettingsClicked() {
  const project = await getProject();
  if (!project) return;

  let enabled = await getIngestEnabled(project);
  log(`IngestEnabled: ${enabled}`);
}

async function setIngestSettingsClicked() {
  const project = await getProject();
  if (!project) return;

  let success = await setIngestEnabled(project);
  log(
    success
      ? "Successfully updated ingest enabled to true"
      : "Failed to update ingest settings"
  );
}

//AppPreference button events
async function getPreferenceSettingClicked() {
  let currSetting = await getPreferenceSetting();
  log(`Current Auto Peak Generation Setting is: ${currSetting}`);
}

async function setPreferenceSettingClicked() {
  let success = await setPreferenceSetting();
  log(
    success
      ? "Successfully updated auto peak generation preference"
      : "Failed to update auto peak generation preference"
  );
}

//Export control button events
async function exportSequenceFrameClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await getActiveSequence(project);
  if (!sequence) {
    log("No active sequence available for export.");
    return;
  }
  let success = await exportSequenceFrame(sequence);
  log(
    success
      ? "Successfully export current frame as png"
      : "Failed to export current frame as png"
  );
}

async function exportSequenceClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await getActiveSequence(project);
  if (!sequence) {
    log("No active sequence available for export.");
    return;
  }

  const success = await exportSequence(sequence);
  log(
    success
      ? "Successfully export sequence as MPEG2"
      : "Failed to export sequence"
  );
}

async function getExportFileExtensionClicked() {
  const project = await getProject();
  if (!project) return;

  const sequence = await getActiveSequence(project);
  if (!sequence) {
    log("No active sequence available for getting exported extension");
    return;
  }

  let presetFile;
  log("Please select a preset file for getting the export file extension");
  // @ts-ignore
  const file = await uxp.storage.localFileSystem.getFileForOpening({
    types: ["epr"],
  });
  if (file?.isFile && file.nativePath) {
    presetFile = file.nativePath;
  } else {
    log("Selection of preset file failed. Please try again");
    return;
  }

  try {
    const extension = await getExportFileExtension(sequence, presetFile);
    log(`Exported file extension will be ${extension}`);
  } catch (err) {
    log(`Error: ${err}`, "red");
  }
}

//import button events
async function importFilesClicked() {
  let success = false;
  // @ts-ignore
  const files = await uxp.storage.localFileSystem.getFileForOpening({
    allowMultiple: true,
  }); // allow multiple files selection
  let filePaths = [];
  if (files.length === 0) {
    log(`No file selected`);
    return;
  } else {
    log(`Importing files selected..`);
    for (const file of files) {
      if (file?.isFile && file.nativePath) {
        filePaths.push(file.nativePath);
      }
    }
  }

  // import into current active project
  const project = await getProject();
  if (project) {
    success = await importFiles(project, filePaths);
  } else {
    log(`no active project found for import`);
  }

  if (success) {
    log(`Import files succeed`);
  } else {
    log(`Failed to import files`);
  }
}

async function importSequencesClicked() {
  // save current proj reference
  const project = await getProject();
  if (!project) return;

  log(`Please open the project which you'd to import all its sequences`);
  // let user open the project containing sequences they'd like to import
  let newProject = await openProject();

  // if no sequence exist, return and alert user
  let sequences: Array<Sequence> = await newProject.getSequences();
  if (sequences.length == 0) {
    log(`no sequence found for import`);
    return;
  }

  // import every sequence inside of project opened to previous active project
  let seqIds = [];
  for (let i = 0; i < sequences.length; i++) {
    seqIds.push(sequences[i].guid);
  }

  log(`Importing sequences into ${project.name}..`);
  // open the original active project
  await openInputProject(project.path);

  const success = await importSequences(project, newProject.path, seqIds);
  if (success) {
    log(`Import sequences succeed`);
  } else {
    log(`Failed to import sequences`);
  }
}

async function importAeComponentClicked() {
  let aeInstalled = await ppro.Utils.isAEInstalled();
  if (!aeInstalled) {
    log(
      `Please ensure that the matching version of "After Effects" is installed on this machine.`,
      `red`
    );
    return;
  }

  const project = await getProject();
  if (!project) return;

  let success = false;
  const rootItem = await project.getRootItem();

  // let user select ae composition file for import
  // @ts-ignore
  const file = await uxp.storage.localFileSystem.getFileForOpening({
    types: ["aep"],
  });
  if (file?.isFile && file.nativePath) {
    // check if user have input for ae composition name for import
    let aeCompName = (
      document.getElementById("ae-component-name") as HTMLInputElement
    )?.value;
    if (!aeCompName) {
      log("Please put name of ae composition in entry");
      return;
    }
    success = await importAeComponent(
      project,
      file.nativePath,
      aeCompName,
      rootItem
    );
  }

  if (success) {
    log(`Import ae composition succeed`);
  } else {
    log(`Failed to import.. Did you put the correct name for composition?`);
  }
}

async function importAllAeComponentsClicked() {
  let aeInstalled = await ppro.Utils.isAEInstalled();
  if (!aeInstalled) {
    log(
      `Please ensure that the matching version of "After Effects" is installed on this machine.`,
      `red`
    );
    return;
  }

  const project = await getProject();
  if (!project) return;

  let success = false;
  const rootItem = await project.getRootItem();
  // @ts-ignore
  // let user select ae composition file for import
  const file = await uxp.storage.localFileSystem.getFileForOpening({
    types: ["aep"],
  });
  if (file?.isFile && file.nativePath) {
    success = await importAllAeComponents(project, file.nativePath, rootItem);
  }
  if (success) {
    log(`Import all ae composition succeed`);
  } else {
    log(`Failed to import ae composition`);
  }
}

window.addEventListener("load", async () => {
  //project events registering
  registerClick("open-project", openProjectClicked);
  registerClick("active-project", getActiveProjectClicked);
  registerClick("active-sequence-project", getActiveSequenceClicked);
  registerClick("open-from-id-project", getProjectFromIdClicked);
  registerClick("get-insertion-bin-project", getInsertionBinClicked);
  registerClick("get-all-sequences-project", getAllSequencesClicked);
  registerClick("open-sequence-project", openSequenceClicked);
  registerClick('pause-project"', pauseGrowingClicked);
  registerClick("save-project", saveProjectClicked);
  registerClick("save-as-project", saveAsProjectClicked);
  registerClick(
    "get-supported-luminances-project",
    getSupportedGraphicsWhiteLuminancesClicked
  );
  registerClick(
    "get-luminance-project",
    getCurrentGraphicsWhiteLuminanceClicked
  );
  registerClick("close-project", closeProjectClicked);

  //sequence events registering
  registerClick("get-sequence-settings", getSequenceSettingsClicked);
  registerClick("set-sequence-settings", setSequencePixelAspectRatioClicked);
  registerClick("set-sequence-in-out-point", setSequenceInOutPointClicked);
  registerClick("get-sequence-from-id", getSequenceClicked);
  registerClick("set-active-sequence", setActiveSequenceClicked);
  registerClick("create-sequence", createSequenceClicked);
  registerClick("create-media-sequence", createSequenceFromMediaClicked);
  registerClick("get-caption-track-count", getCaptionTrackCountClicked);
  registerClick("get-video-track-sequence", getVideoTrackClicked);
  registerClick("get-selection-sequence", getSequenceSelectionClicked);
  registerClick("set-selection-sequence", setSequenceSelectionClicked);
  registerClick("create-sub-sequence", createSubsequenceClicked);
  registerClick("overwrite-item", overwriteItemClicked);
  registerClick("insert-item", insertItemClicked);
  registerClick("insert-mogrt", insertMogrtClicked);
  registerClick("clone-selected-item", cloneSelectedItemClicked);
  registerClick("remove-selected-items", removeSelectedItemClicked);
  registerClick("trim-selected-item", trimSelectedItemClicked);
  registerClick("trim-handles", trimHandlesClicked);
  registerClick(
    "rename-first-selected-trackItem",
    renameFirstSelectedTrackItemClicked
  );

  //marker events registering
  registerClick("marker-comment", createMarkerCommentClicked);
  registerClick("marker-chapter", createMarkerChapterClicked);
  registerClick("marker-weblink", createMarkerWeblinkClicked);
  registerClick("marker-flashcuepoint", createMarkerFlashCuePointClicked);
  registerClick("marker-movemarker", moveMarkerClicked);
  registerClick("marker-removemarker", removeMarkerClicked);
  registerClick("marker-info-sequence", getSequenceMarkerInfoClicked);

  //metadata events registering
  registerClick("get-project-metadata", getProjectMetadataClicked);
  registerClick("get-xmp-metadata", getXMPMetadataClicked);
  registerClick(
    "get-projectcolumns-metadata",
    getProjectColumnsMetadataClicked
  );
  registerClick("get-projectpanel-metadata", getProjectPanelMetadataClicked);
  registerClick("set-xmp-metadata", setXMPMetadataClicked);
  registerClick("set-projectpanel-metadata", setProjectPanelMetadatClicked);
  registerClick(
    "add-property-metadata-schema",
    addPropertiesToMetadataSchemaClicked
  );
  registerClick("set-project-metadata", setProjectMetadataClicked);

  //source monitor events registering
  registerClick("open-filePath", openFilePathClicked);
  registerClick("open-projectItem", openProjectItemClicked);
  registerClick("play", playClicked);
  registerClick("get-pos", getPositionClicked);
  registerClick("close-clip", closeClipClicked);
  registerClick("close-all-clips", closeAllClipsClicked);

  //keyframe events registering
  registerClick("set-value", setValueClicked);
  registerClick("get-start-value", getStartValueClicked);
  registerClick("add-keyframe", addKeyframeClicked);
  registerClick("get-keyframes", getKeyframesClicked);
  registerClick("get-keyfram-time", getKeyframeClicked);
  registerClick("set-interpolation", setInterpolationClicked);

  //project panel item events registering
  registerClick("get-project-items", getProjectItemsClicked);
  registerClick("get-selected-project-items", getSelectedProjectItemsClicked);
  registerClick("get-media-path", getMediaFilePathClicked);
  registerClick("get-media-info", getMediaInfoClicked);
  registerClick("set-media-start", setMediaStartClicked);
  registerClick("create-bin", createBinClicked);
  registerClick("create-smart-bin", createSmartBinClicked);
  registerClick("rename-bin", renameBinClicked);
  registerClick("remove-item", removeItemClicked);
  registerClick("move-item", moveItemClicked);
  registerClick("set-in-out-point", setInOutPointClicked);
  registerClick("clear-in-out-point", clearInOutPointClicked);
  registerClick("set-override-framerate", setOverrideFrameRateClicked);
  registerClick(
    "set-override-pixel-aspect-ratio",
    setOverridePixelAspectRatioClicked
  );
  registerClick("set-scale-to-frame-size", setScaleToFrameSizeClicked);
  registerClick("set-footage-interpretation", setFootageInterpretationClicked);
  registerClick("set-footage-interpretation", setFootageInterpretationClicked);
  registerClick("refresh-media", refreshMediaClicked);
  registerClick("attach-proxy", attachProxyClicked);
  registerClick("change-path", changePathClicked);
  registerClick("get-view-ids", getProjectViewIdsClicked);
  registerClick("get-project-from-view-id", getProjectFromViewIdClicked);
  registerClick("get-selection-from-view-id", getSelectionFromViewIdClicked);
  registerClick(
    "rename-first-selected-projectItem",
    renameFirstSelectedProjectItemClicked
  );

  //Effects & transitions
  registerClick("get-effect-names", getEffectsNameClicked);
  registerClick("add-gamma-correction-effect", addEffectsClicked);
  registerClick("add-multiple-effects", addMultipleEffectsClicked);
  registerClick("remove-gamma-correction-effect", removeEffectsClicked);
  registerClick("get-transition-names", getTransitionNamesClicked);
  registerClick("add-transition-start", addTransitionStartClicked);
  registerClick("add-transition-end", addTransitionEndClicked);
  registerClick("remove-transition-start", removeTransitionStartClicked);
  registerClick("add-vocal-enhancer-effect", addVocalEnhancerEffectClicked);

  // Properties
  registerClick("get-sequence-property", getSampleSequencePropertyClicked);
  registerClick("set-sequence-property", setSampleSequencePropertyClicked);
  registerClick("clear-sequence-property", clearSampleSequencePropertyClicked);

  // Settings
  registerClick("get-project-setting", getScratchDiskSettingClicked);
  registerClick("set-project-setting", setScratchDiskSettingsClicked);
  registerClick("get-ingest-setting", getIngestSettingsClicked);
  registerClick("set-ingest-enabled", setIngestSettingsClicked);

  // AppPreference
  registerClick("get-autopeak-preference", getPreferenceSettingClicked);
  registerClick("set-autopeak-setting", setPreferenceSettingClicked);

  // Export
  registerClick("export-frame", exportSequenceFrameClicked);
  registerClick("export-sequence", exportSequenceClicked);
  registerClick("get-export-file-extension", getExportFileExtensionClicked);

  // Import controls
  registerClick("import-ae-component", importAeComponentClicked);
  registerClick("import-files", importFilesClicked);
  registerClick("import-all-ae-components", importAllAeComponentsClicked);
  registerClick("import-sequences", importSequencesClicked);

  document
    .querySelector(".clear-btn")!
    .addEventListener("click", () => clearLog());

  // add project & seq open/close/activate event listeners. Details in eventManager.ts
  await addProjSeqListeners();

  // add encoder event listeners. Details in eventManager.ts
  await addEncoderListeners();
});

//Helper functions
document
  .querySelector(".clear-btn")!
  .addEventListener("click", () => clearLog());

async function getProject() {
  const activeProject = await getActiveProject();
  if (activeProject) {
    return activeProject;
  } else {
    log(`Failed to find active project`, "red");
  }
}
```

## File: html/manifest.json
```json
{
  "id": "com.adobe.ppro.samples",
  "name": "PremierePro UXP plugin Sample Project",
  "shortname": "3psample",
  "version": "1.0.0",
  "main": "index.html",
  "host": {
      "app": "premierepro",
      "minVersion": "25.1.0"
  },
  "manifestVersion": 5,
  "requiredPermissions": {
    "localFileSystem": "request",
    "clipboard": "readAndWrite"
  },
  "entrypoints": [
    {
      "id": "samplepanel",
      "type": "panel",
      "minimumSize": {
        "width": 430,
        "height": 500
      },
      "maximumSize": {
        "width": 2000,
        "height": 2000
      },
      "preferredDockedSize": {
        "width": 230,
        "height": 300
      },
      "preferredFloatingSize": {
        "width": 400,
        "height": 300
      },
      "label": {
        "default": "PremierePro UXP plugin Sample Project"
      },
      "icons": [
        {
          "width": 23,
          "height": 23,
          "path": "icons/dark.png",
          "scale": [1, 2],
          "theme": ["darkest", "dark", "medium"]
        },
        {
          "width": 23,
          "height": 23,
          "path": "icons/light.png",
          "scale": [1, 2],
          "theme": ["lightest", "light"]
        }
      ]
    }
  ],
  "icons": [
    {
      "width": 48,
      "height": 48,
      "path": "icons/plugin-icon.png",
      "scale": [1, 2],
      "theme": ["darkest", "dark", "medium", "lightest", "light", "all"],
      "species": ["pluginList"]
    }
  ]
}
```

## File: html/package.json
```json
{
  "type": "commonjs",
  "scripts": {
    "clean": "rimraf ../build-html",
    "copy": "cp-cli ../html ../build-html",
    "compile": "tsc",
    "fix-imports": "node ./scripts/fix-imports.js",
    "build": "npm run clean && npm run copy && npm run compile && npm run fix-imports"
  },
  "devDependencies": {
    "@adobe/cc-ext-uxp-types": "^7.3.1",
    "@types/node": "^22.10.2",
    "cp-cli": "^2.0.0",
    "tslib": "^2.8.1",
    "typescript": "^5.7.2",
    "rimraf": "^6.0.1"
  }
}
```

## File: html/tsconfig.json
```json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "target": "ESNext",
    "useDefineForClassFields": true,
    "module": "CommonJS",
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": true,
    "isolatedModules": true,
    "types": ["@adobe/cc-ext-uxp-types", "@types/node"],
    "outDir": "../build-html",
    "noImplicitAny": null,
    "esModuleInterop": true
  },
  "include": ["./**/*.d.ts", "./**/*.ts", "./**/*.js", "package.json"],
  "exclude": ["node_modules", "scripts"]
}
```

## File: html/types.d.ts
```typescript
export declare type premierepro = {
  AppPreference: AppPreferenceStatic
  AudioClipTrackItem: AudioClipTrackItemStatic
  AudioComponentChain: AudioComponentChainStatic
  AudioFilterComponent: AudioFilterComponentStatic
  AudioFilterFactory: AudioFilterFactoryStatic
  AudioTrack: AudioTrackStatic
  CaptionTrack: CaptionTrackStatic
  ClipProjectItem: ClipProjectItemStatic
  EncoderManager: EncoderManagerStatic
  Exporter: ExporterStatic
  FolderItem: FolderItemStatic
  FrameRate: FrameRateStatic
  Guid: GuidStatic
  Keyframe: KeyframeStatic
  Marker: MarkerStatic
  Markers: MarkersStatic
  Metadata: MetadataStatic
  OperationCompleteEvent: OperationCompleteEventStatic
  Project: ProjectStatic
  ProjectClosedEvent: ProjectClosedEventStatic
  ProjectEvent: ProjectEventStatic
  ProjectItem: ProjectItemStatic
  ProjectSettings: ProjectSettingsStatic
  ProjectUtils: ProjectUtilsStatic
  Properties: PropertiesStatic
  ScratchDiskSettings: ScratchDiskSettingsStatic
  Sequence: SequenceStatic
  SequenceEditor: SequenceEditorStatic
  SequenceSettings: SequenceSettingsStatic
  SequenceUtils: SequenceUtilsStatic
  SnapEvent: SnapEventStatic
  SourceMonitor: SourceMonitorStatic
  TickTime: TickTimeStatic
  TrackItemSelection: TrackItemSelectionStatic
  TransitionFactory: TransitionFactoryStatic
  Utils: UtilsStatic
  VideoClipTrackItem: VideoClipTrackItemStatic
  VideoComponentChain: VideoComponentChainStatic
  VideoFilterComponent: VideoFilterComponentStatic
  VideoFilterFactory: VideoFilterFactoryStatic
  VideoTrack: VideoTrackStatic
  VideoTransition: VideoTransitionStatic
  EventManager: EventManagerStatic
  AddTransitionOptions: AddTransitionOptions
  Constants: typeof Constants
}

export declare type Action = {
}

export declare type AddTransitionOptions = {
  (): AddTransitionOptions
  setApplyToStart(applyToStart: boolean): AddTransitionOptions	//Set whether to apply transition to the start or end of trackitem
  setForceSingleSided(forceSingleSided: boolean): AddTransitionOptions	//Set whether transition should be applied to one/both sides
  setTransitionAlignment(transitionAlignment: number): AddTransitionOptions	//Sets the transitionAlignment of the transition
  setDuration(tickTime: TickTime): AddTransitionOptions	//Sets the duration of transition
  applyToStart: boolean	//Get whether to apply transition to the start or end of trackitem
  forceSingleSided: boolean	//Get whether transition should be applied to one/both sides
  transitionAlignment: number	//Gets the transitionAlignment of transition
  duration: TickTime	//Gets the duration of transition
}

export declare type AppPreferenceStatic = {
  setValue(key: Constants.PreferenceKey, value: boolean | string | number, persistenceFlag: Constants.PropertyType): boolean	//Set backend preference using given list of property keys. The parameters are <key, value (number, boolean or string), persistence flag>
  getValue(preferenceKey: Constants.PreferenceKey): string	//Get preference value in native string form
  KEY_AUTO_PEAK_GENERATION: string	//Preference string key used to modify auto-peak generation settings
  KEY_IMPORT_WORKSPACE: string	//Preference string key used to modify import workspace settings
  KEY_SHOW_QUICKSTART_DIALOG: string	//Preference string key used to modify show quickstart dialog settings
  PROPERTY_PERSISTENT: number	//Property is persistent in backend and shared across cloud project.
  PROPERTY_NON_PERSISTENT: number	//Property is not persisted and will be cleared when the project closes.
}

export declare type AppPreference = {
}

export declare type Application = {
  version: string
}

export declare type AudioClipTrackItemStatic = {
  TRACKITEMTYPE_EMPTY: number	//Empty Track Item Type
  TRACKITEMTYPE_CLIP: number	//Clip Track Item Type
  TRACKITEMTYPE_TRANSITION: number	//Transition Track Item Type
  TRACKITEMTYPE_PREVIEW: number	//Previe Track Item Type
  TRACKITEMTYPE_FEEDBACK: number	//Feedback Track Item Type
}

export declare type AudioClipTrackItem = {
  getMatchName(): Promise<string>	//Returns the value of internal matchname for this trackItem
  getName(): Promise<string>	//Returns the display name for trackItem
  getIsSelected(): Promise<boolean>	//Returns if trackItem is selected or not
  getSpeed(): Promise<number>	//Returns the value of speed of the trackItem
  isAdjustmentLayer(): Promise<boolean>	//Returns true if the trackitem is an adjustment layer
  isSpeedReversed(): Promise<number>	//Returns true if the trackitem is reversed
  createMoveAction(tickTime: TickTime): Action	//Returns an action that moves the inPoint of the track item to a new time, by shifting it by a number of seconds.
  getInPoint(): Promise<TickTime>	//Returns a TickTime object representing the track item in point relative to the start time of the project item referenced by this track item.
  getOutPoint(): Promise<TickTime>	//Returns a TickTime object representing the track item out point relative to the start time of the project item referenced by this track item.
  createSetInPointAction(tickTime: TickTime): Action	//Create SetInPointAction for setting the track item in point relative to the start time of the project item referenced by this track item
  createSetOutPointAction(tickTime: TickTime): Action	//Create SetOutPointAction for setting the track item out point relative to the start time of the project item referenced by this track item
  getStartTime(): Promise<TickTime>	//Returns a TickTime object representing the starting sequence time of this track item relative to the sequence start time.
  getEndTime(): Promise<TickTime>	//Returns a TickTime object representing the ending sequence time of this track item relative to the sequence start time.
  createSetStartAction(tickTime: TickTime): Action	//Create set start time action for sequence
  createSetEndAction(tickTime: TickTime): Action	//Create set end time action for sequence
  getDuration(): Promise<TickTime>	//Returns timecode representing the duration of this track item relative to the sequence start.
  getType(): Promise<number>	//Index representing the type of this track item.
  isDisabled(): Promise<boolean>	//Returns true if trackitem is muted/disabled
  createSetDisabledAction(disabled: boolean): Action	//Returns an action that enables/disables the trackItem 
  createSetNameAction(inName: string): Action	//Returns an action that renames the trackItem
  getMediaType(): Promise<Guid>	//Returns UUID representing the underlying media type of this track item
  getTrackIndex(): Promise<number>	//Index representing the track index of the track this track item belongs to
  getProjectItem(): Promise<ProjectItem>	//Returns the project item for this track item.
  getComponentChain(): Promise<AudioComponentChain>	//Returns AudioComponentChain
}

export declare type AudioComponentChainStatic = {
}

export declare type AudioComponentChain = {
  createInsertComponentAction(component: Component | AudioFilterComponent, componentInsertionIndex: number): Action	//Creates and returns an insert component action
  createAppendComponentAction(component: Component | AudioFilterComponent): Action	//Creates and returns an append component action
  createRemoveComponentAction(component: Component | AudioFilterComponent): Action	//Creates and returns an remove component action
  getComponentAtIndex(componentIndex: number): Component	//Returns the component at the given index
  getComponentCount(): number	//Gets the number of components in the component chain
}

export declare type AudioFilterComponentStatic = {
}

export declare type AudioFilterComponent = {
}

export declare type AudioFilterFactoryStatic = {
  createComponentByDisplayName(displayName: string, inAudioClipTrackItem: AudioClipTrackItem): Promise<AudioFilterComponent>	//Creates a new audio filter component based on the input display name and trackItem for applying the audio filter
  getDisplayNames(): Promise<string[]>	//Returns an array of audio filter displayNames
}

export declare type AudioFilterFactory = {
}

export declare type AudioTrackStatic = {
  EVENT_TRACK_CHANGED: string	//Event Object for Track changed
  EVENT_TRACK_INFO_CHANGED: string	//Event Object for Track Info Changed
  EVENT_TRACK_LOCK_CHANGED: string	//Event Object for Track Lock Changed
}

export declare type AudioTrack = {
  setMute(mute: boolean): Promise<boolean>	//sets the mute state of the track to muted/unmuted
  getMediaType(): Promise<Guid>	//UUID representing the underlying media type of this track
  getIndex(): Promise<number>	//Index representing the track index of this track within the track group.
  isMuted(): Promise<boolean>	//Get mute state of the track
  getTrackItems(trackItemType: Constants.TrackItemType, includeEmptyTrackItems: boolean): AudioClipTrackItem[]	//Returns array of AudioClipTrackItem from the track item type
  name: string	//Get the name of the track
  id: number	//The ID of the track within the TrackGroup
}

export declare type CaptionTrackStatic = {
}

export declare type CaptionTrack = {
  setMute(mute: boolean): Promise<boolean>	//sets the mute state of the track to muted/unmuted
  getMediaType(): Promise<Guid>	//UUID representing the underlying media type of this track
  getIndex(): Promise<number>	//Index representing the track index of this track within the track group.
  isMuted(): Promise<boolean>	//Get mute state of the track
  getTrackItems(trackItemType: number, includeEmptyTrackItems: boolean): []	//Returns the track items of the specified media type from the given track
  name: string	//Get the name of the track
  id: number	//The ID of the track within the TrackGroup
}

export declare type ClipProjectItemStatic = {
  cast(projectItem: ProjectItem): ClipProjectItem	//Cast ProjectItem in to ClipProjectItem
}

export declare type ClipProjectItem = {
  getInputLUTID(): Promise<string>	//Get Guid of Input LUT overridden on media
  createSetInputLUTIDAction(stringLUTID: string): Action	//Create action for setting Guid of Input LUT on media. This applies for Video Clips only.
  isSequence(): Promise<boolean>	//Returns true if the project item is a sequence
  canChangeMediaPath(): Promise<boolean>	//Returns true if Premiere Pro can change the path associated with this project item; otherwise, returns false
  isOffline(): Promise<boolean>	//Returns true if the media is offline
  canProxy(): Promise<boolean>	//Indicates whether it is possible to attach a proxy to this project item.
  getProxyPath(): Promise<string>	//Returns the proxy path if the project item has a proxy attached
  hasProxy(): Promise<boolean>	//Indicates whether a proxy has already been attached to the project item.
  attachProxy(mediaPath: string, isHiRes: boolean, inMakeAlternateLinkInTeamProjects?: boolean): Promise<boolean>	//Attach proxy or high resolution footage to projectItem and returns true if successful. Not undoable.
  findItemsMatchingMediaPath(matchString: string, ignoreSubclips?: boolean): Promise<ProjectItem[]>	//Returns array of project's items with media paths containing match string
  refreshMedia(): Promise<boolean>	//Updates representation of the media associated with the project item
  createSetOfflineAction(): Action	//Returns an action which sets the media offline
  getFootageInterpretation(): Promise<FootageInterpretation>	//Get the footage interpretation object for project item
  createSetFootageInterpretationAction(footageInterpretation: FootageInterpretation): Action	//Set the footage interpretation object for project item
  changeMediaFilePath(newPath: string, overrideCompatibilityCheck?: boolean): Promise<boolean>	//Change media file path of projectItem and returns true if successful. Not undoable.
  isMergedClip(): Promise<boolean>	//Returns true if the clip Project item is a merged clip
  isMulticamClip(): Promise<boolean>	//Returns true if the clip Project item is a multicam clip
  getEmbeddedLUTID(): Promise<string>	//Get GUID of LUT embedded in media
  createSetScaleToFrameSizeAction(): Action	//Returns an action which sets the scale to frame to true
  createSetNameAction(inName: string): Action	//Returns action that renames projectItem
  getParent(): Promise<ProjectItem>	//Get the parent project item of this project item.
  getProject(): Promise<Project>	//Get the parent Project of this projectItem.
  getContentType(): Promise<Constants.ContentType>	//Get content type of the Project item
  getSequence(): Promise<Sequence>	//Get the sequence of the Project item
  getInPoint(mediaType: Constants.MediaType): Promise<TickTime>	//Get the in point of the Project item
  getOutPoint(mediaType: Constants.MediaType): Promise<TickTime>	//Get the out point of the Project item
  getMediaFilePath(): Promise<string>	//Get the media file path of the Project item.
  getComponentChain(mediaType: Constants.MediaType): Promise<string>	//Get the media file path of the Project item.
  createSetInPointAction(tickTime: TickTime): Action	//Returns an action which Sets the in point of the Project item
  createSetOverridePixelAspectRatioAction(inNumerator: number, inDenominator: number): Action	//Returns an action which sets Override pixel aspect ratio
  createSetOverrideFrameRateAction(inOverriddenFrameRateValue: number): Action	//Returns an action which sets the override frame rate
  createSetOutPointAction(tickTime: TickTime): Action	//Returns an action which Sets the in point of the Project item
  createSetInOutPointsAction(inPoint: TickTime, outPoint: TickTime): Action	//Set the in or out point of the Project item
  createClearInOutPointsAction(): Action	//Create Clear the in or out point of the Project item action
  getMedia(): Promise<Media>	//Return media associated with clipProjectItem
  name: string	//The name of this project item.
}

export declare type CloseProjectOptions = {
  (): CloseProjectOptions
  setPromptIfDirty(promptIfDirty: boolean): CloseProjectOptions	//Set whether to prompt if a project is dirty on project open/close
  setShowCancelButton(showCancelButton: boolean): CloseProjectOptions	//Set whether to show the cancel button on project open/close
  setIsAppBeingPreparedToQuit(isAppBeingPreparedToQuit: boolean): CloseProjectOptions	//Set whether the app should be prepared to quit when open/closing a project
  setSaveWorkspace(isAppBeingPreparedToQuit: boolean): CloseProjectOptions	//Set whether to save your workspaces when opening/closing a project
  promptIfDirty: boolean	//Get whether a prompt is shown if a project is dirty on project open/close
  showCancelButton: boolean	//Get whether the cancel button is shown on project open/close
  isAppBeingPreparedToQuit: boolean	//Get whether the app is prepared to quit when open/closing a project
  saveWorkspace: boolean	//Get whether your workspaces are saved when opening/closing a project
}

export declare type Color = {
  (red?: number, green?: number, blue?: number, alpha?: number): Color
  equals(colorObject: Color): boolean	//Returns true if the given ColorObject is equal to this ColorObject
  red: number	//Read/Write property to get/set red value of color object
  green: number	//Read/Write property to get/set green value of color object
  blue: number	//Read/Write property to get/set blue value of color object
  alpha: number	//Read/Write property to get/set alpha value of color object
}

export declare type Component = {
  getParam(paramIndex?: number): ComponentParam	//Get a parameter from the component based on the given input index. Parameter indexes are zero-based, and the actual is defined exclusively by the component itself.
  getMatchName(): Promise<string>	//Returned Promise will be fullfilled with the value of internal matchname for this component
  getDisplayName(): Promise<string>	//Returned Promise will be fullfilled with the value of display name for this component
  getParamCount(): number	//Gets the number of param in the component
}

export declare type ComponentParam = {
  createKeyframe(inValue: number | string | boolean | PointF | Color): Keyframe	//Creates and returns a keyframe initialised with the ComponentParam's type and passed in value. This throws if the passed in value is not compatible with the component param type
  getValueAtTime(time: TickTime): Promise<number | string | boolean | PointF | Color>	//Gets the value of component Param at the given time
  findNearestKeyframe(inTime: TickTime, outTime: TickTime): Keyframe	//Find sthe nearest key for the given time
  findNextKeyframe(inTime: TickTime): Keyframe	//find the next keyframe for the given time
  findPreviousKeyframe(inTime: TickTime): Keyframe	//find the previous keyframe for the given time
  createRemoveKeyframeAction(inTime: TickTime, UpdateUI?: boolean): Action	//Returns an action which removes keyframe at specific time
  createRemoveKeyframeRangeAction(inTime: TickTime, outTime: TickTime, UpdateUI?: boolean): Action	//Returns an action which removes keyframe at specific time range
  createSetValueAction(inKeyFrame: Keyframe, inSafeForPlayback?: boolean): Action	//Creates and returns an action object which can be used to set the value of a non-time varying component
  createAddKeyframeAction(inKeyFrame: Keyframe): Action	//Creates and returns an action object which can be used to add a keyframe component
  createSetTimeVaryingAction(inTimeVarying: boolean): Action	//Creates and returns an action object to set the component to be time varying
  getStartValue(): Promise<Keyframe>	//Returned promise will be fullfilled with the start value (keyframe) of the component param
  getKeyframeListAsTickTimes(): TickTime[]	//Get a list of tickTime for the keyframes of this component param
  getKeyframePtr(time?: TickTime): Keyframe	//Get the Keyframe at the given tickTime postion
  isTimeVarying(): boolean	//Returns true if the parameter value varies over time (for the duration of the item)
  createSetInterpolationAtKeyframeAction(inTime: TickTime, InterpolationMode: number, UpdateUI?: boolean): Action	//Returns an action which sets the interpolation mode of keyframe at the given time
  areKeyframesSupported(): Promise<boolean>	//Returns bool whether keyframes are supported for this component parameter
  displayName: string	//Returns the display name of the component param
}

export declare type CompoundAction = {
  addAction(action: Action): boolean	//Add an action to the compound action
  empty: boolean	//Is the compound action empty?
}

export declare type EncoderManagerStatic = {
  getManager(): EncoderManager	//Get the Encoder Manager object.
  getExportFileExtension(sequence: Sequence, presetFilePath: string): Promise<string>	//Get the Export File Extension of Input Preset file
  EXPORT_QUEUE_TO_AME: string	//Export type used to queue an export job into the Adobe Media Encoder export queue
  EXPORT_QUEUE_TO_APP: string	//Export type used to queue an export job into the app export queue
  EXPORT_IMMEDIATELY: string	//Export type used to immediately exporting an object
  EVENT_RENDER_COMPLETE: string	//Broadcast when AME is finished rendering
  EVENT_RENDER_ERROR: string	//Broadcast when AME gives back error message
  EVENT_RENDER_CANCEL: string	//Broadcast when AME job is canceled
  EVENT_RENDER_QUEUE: string	//Broadcast when AME job is queued
  EVENT_RENDER_PROGRESS: string	//Broadcast when AME job is rendering the job
}

export declare type EncoderManager = {
  exportSequence(sequence: Sequence, exportType: Constants.ExportType, outputFile?: string, presetFile?: string, exportFull?: boolean): Promise<boolean>	//Export a sequence. If no output file and preset is specified, the sequence will be exported with the applied export settings or standard export rules will be applied.
  isAMEInstalled: boolean	//Check if AME is installed.
}

export declare type ExporterStatic = {
  exportSequenceFrame(sequence: Sequence, time: TickTime, filename: string, filepath: string, width: number, height: number): Promise<boolean>	//Exports from a sequence. Supported formats are bmp, dpx, gif, jpg, exr, png, tga and tif
}

export declare type Exporter = {
}

export declare type FolderItemStatic = {
  cast(projectItem: ProjectItem): FolderItem	//Cast ProjectItem in to FolderItem
}

export declare type FolderItem = {
  createBinAction(name: string, makeUnique: boolean): Action	//Returns an action that lets users create a new bin.
  createSmartBinAction(name: string, searchQuery: string): Action	//Creates a smart bin with given name and returns the Folder object
  createRenameBinAction(name: string): Action	//Rename the Bin and return true if it's successful
  getItems(): Promise<ProjectItem[]>	//Collection of child items of this folder.
  createRemoveItemAction(item: ProjectItem): Action	//Creates an action that removes the given item from this folder.
  createMoveItemAction(item: ProjectItem, newParent: FolderItem): Action	//Creates an action that moves the given item to the provided folder item newParent.
  createSetNameAction(inName: string): Action	//Returns action that renames projectItem
  getParent(): Promise<ProjectItem>	//Get the parent project item of this project item.
  getProject(): Promise<Project>	//Get the parent Project of this projectItem.
  name: string	//The name of this project item.
}

export declare type FootageInterpretation = {
  getFrameRate(): number	//Get frame rate of footage
  setFrameRate(frameRate: number): boolean	//Set frame rate of footage
  getPixelAspectRatio(): number	//Get pixel aspect ratio of footage
  setPixelAspectRatio(pixelAspectRatio: number): boolean	//Set pixel aspect ratio of footage
  getFieldType(): number	//Get field type of footage
  setFieldType(fieldType: number): boolean	//Set field type of footage
  getRemovePullDown(): boolean	//Get removePullDown property of footage
  setRemovePullDown(removePulldown: boolean): boolean	//Set removePullDown property of footage
  getAlphaUsage(): number	//Get alpha usage type property of footage
  setAlphaUsage(alphaUsage: number): boolean	//Set alpha usage type property of footage
  getIgnoreAlpha(): boolean	//Get ignore alpha property of footage
  setIgnoreAlpha(ignoreAlpha: boolean): boolean	//Set ignore alpha property of footage
  getInvertAlpha(): boolean	//Get invert alpha property of footage
  setInvertAlpha(invertAlpha: boolean): boolean	//Set invert alpha property of footage
  getVrConform(): number	//Get vr conform projection type of footage
  setVrConform(vrConform: number): boolean	//Set vr conform projection type of footage
  getVrLayout(): number	//Get vr layout type of footage
  setVrLayout(vrLayOut: number): boolean	//Set vr layout type of footage
  getVrHorzView(): number	//Get vr horizontal view of footage
  setVrHorzView(vrHorzView: number): boolean	//Set vr horizontal view of footage
  getVrVertView(): number	//Get vr vertical view of footage
  setVrVertView(vrVertView: number): boolean	//Set vr horizontal view of footage
  getInputLUTID(): string	//Get input LUTID of footage
  setInputLUTID(inputLUTID: string): boolean	//Set input LUTID of footage
  ALPHACHANNEL_NONE: number	//alpha channel none
  ALPHACHANNEL_STRAIGHT: number	//alpha channel straight
  ALPHACHANNEL_PREMULTIPLIED: number	//alpha channel premultiplied
  ALPHACHANNEL_IGNORE: number	//alpha channel ignore
  FIELD_TYPE_DEFAULT: number	//default filed type invalid
  FIELD_TYPE_PROGRESSIVE: number	//field type progressive
  FIELD_TYPE_UPPERFIRST: number	//field type upperfirst
  FIELD_TYPE_LOWERFIRST: number	//field type lowerfirst
}

export declare type FrameRateStatic = {
  createWithValue(value: number): FrameRate	//Create frame rate object with a value
}

export declare type FrameRate = {
  (): FrameRate
  equals(frameRate: FrameRate): boolean	//Returns true if the given FrameRate is equal to this FrameRate object
  ticksPerFrame: number	//Read/Write property to get/set ticks per frame.
  value: number	//Get the number of frames per second.
}

export declare type GuidStatic = {
  fromString(stringValue: string): Guid	//Create a guid from a string
}

export declare type Guid = {
  (): Guid
  toString(): string	//Return string representation of the GUID
}

export declare type IngestSettings = {
  getIsIngestEnabled(): Promise<boolean>	//Get whether or not ingest is enabled
  setIngestEnabled(enabled: boolean): Promise<boolean>	//Set whether or not ingest is enabled
}

export declare type KeyframeStatic = {
  INTERPOLATION_MODE_LINEAR: number	//Linear interpolation mode
  INTERPOLATION_MODE_HOLD: number	//Hold interpolation mode
  INTERPOLATION_MODE_BEZIER: number	//Bezier interpolation mode
  INTERPOLATION_MODE_TIME: number	//Time interpolation mode
  INTERPOLATION_MODE_TIME_TRANSITION_START: number	//Time transition start interpolation mode
  INTERPOLATION_MODE_TIME_TRANSITION_END: number	//Time transition end interpolation mode
}

export declare type Keyframe = {
  getTemporalInterpolationMode(): Promise<number>	//Gets temporal interpolation mode of a keyframe
  setTemporalInterpolationMode(temporalInterpolationMode: number): Promise<boolean>	//Sets temporal interpolation mode of a keyframe
  value: {value: string | number | boolean | Color | PointF}
  position: TickTime	//Get/Set position of a keyframe
}

export declare type MarkerStatic = {
  MARKER_TYPE_COMMENT: string	//Marker Type: Comment
  MARKER_TYPE_CHAPTER: string	//Marker Type: Chapter
  MARKER_TYPE_FLVCUEPOINT: string	//Marker Type: FLVCuePoint
  MARKER_TYPE_WEBLINK: string	//Marker Type: WebLink
}

export declare type Marker = {
  getColor(): Color	//Get color code of the marker.
  getComments(): string	//Get comments of the marker.
  getDuration(): TickTime	//Get duration time of the marker.
  getName(): string	//Get name of the marker.
  getUrl(): string	//Get url of the marker.
  getTarget(): string	//Get target of the marker. Used together with url for web targets.
  getType(): string	//Get type of the marker. e.g. Cue / Track / Subclip / Cart
  getStart(): TickTime	//Get start time of the marker.
  createSetNameAction(name: string): Action	//Return an action to set the name of the marker.
  createSetDurationAction(tickTime: TickTime): Action	//Return an action to set the duration of the marker.
  createSetTypeAction(markerType: string): Action	//Return an action to set the type of the marker.
  createSetCommentsAction(comments: string): Action	//Return an action to set the comments of the marker.
}

export declare type MarkersStatic = {
  getMarkers(markerOwnerObject: Sequence | ProjectItem): Promise<Markers>	//Returns the Markers object for Sequence Or ProjectItem
}

export declare type Markers = {
  getMarkers(filters?: string[]): Marker[]	//Get all markers
  createRemoveMarkerAction(marker: Marker): Action	//Remove the given marker
  createMoveMarkerAction(marker: Marker, tickTime: TickTime): Action	//Move the given marker at new time value
  createAddMarkerAction(Name: string, markerType?: string, startTime?: TickTime, duration?: TickTime, comments?: string): Action	//Add a new marker
}

export declare type Media = {
  createSetStartAction(time: TickTime): Action	//Returns action that set start of media
  start: Promise<TickTime>	//Get the media start time
  duration: Promise<TickTime>	//Get the media duration
}

export declare type MetadataStatic = {
  getProjectMetadata(projectItem: ProjectItem): Promise<string>	//Get project metadata
  getXMPMetadata(projectItem: ProjectItem): Promise<string>	//Get project XMP metadata
  createSetProjectMetadataAction(projectItem: ProjectItem, metadata: string, updatedFields: string[]): Action	//Get set project metadata action
  createSetXMPMetadataAction(projectItem: ProjectItem, metadata: string): Action	//Get set project XMP metadata action
  addPropertyToProjectMetadataSchema(name: string, label: string, type: number): Promise<boolean>	//Add name and label property to project metadata schema
  getProjectColumnsMetadata(projectItem: ProjectItem): Promise<string>	//Get project column metadata from project item
  getProjectPanelMetadata(): Promise<string>	//Get project panel metadata
  setProjectPanelMetadata(metadata: string): Promise<boolean>	//Set project panel metadata
  METADATA_TYPE_INTEGER: number	//Metadata Type: INTEGER
  METADATA_TYPE_REAL: number	//Metadata Type: REAL
  METADATA_TYPE_TEXT: number	//Metadata Type: TEXT
  METADATA_TYPE_BOOLEAN: number	//Metadata Type: BOOLEAN
}

export declare type Metadata = {
}

export declare type OpenProjectOptions = {
  setShowConvertProjectDialog(showConvertProjectDialog: boolean): OpenProjectOptions	//Set whether to show the convert project dialog on project open/close
  setShowLocateFileDialog(showLocateFileDialog: boolean): OpenProjectOptions	//Set whether to show the locate file dialog on project open/close
  setShowWarningDialog(showConvertProjectDialog: boolean): OpenProjectOptions	//Set whether to show the warning file dialog on project open/close
  setAddToMRUList(addToMRUList: boolean): OpenProjectOptions	//Set whether to add to MRU list after project changes
  showConvertProjectDialog: boolean	//Get whether the convert project dialog is shown on project open/close
  showLocateFileDialog: boolean	//Get whether locate file dialog is shown on project open/close
  showWarningDialog: boolean	//Get whether the warning file dialog is shown on project open/close
  addToMRUList: boolean	//Get whether to add project changes to MRU list
}

export declare type OperationCompleteEventStatic = {
  OPERATION_STATE_SUCCESS: number	//Represents the state when an operation completes successfully.
  OPERATION_STATE_CANCELLED: number	//Represents the state when an operation is cancelled.
  OPERATION_STATE_FAILED: number	//Represents the state when an operation is failed.
  EVENT_IMPORT_MEDIA_COMPLETE: string	//Event occurs when a media import operation is complete.
  EVENT_EXPORT_MEDIA_COMPLETE: string	//Event occurs when a media export operation is complete.
  EVENT_EFFECT_DROP_COMPLETE: string	//Event occurs when an effect is dropped on a trackitem
  EVENT_EFFECT_DRAG_OVER: string	//Event occurs when an effect is drag over a trackitem
  EVENT_CLIP_EXTEND_REACHED: string	//Event occurs when a clip reached its maximum extend limit.
  EVENT_GENERATIVE_EXTEND_COMPLETE: string	//Event occurs when a generative extend operation is complete.
}

export declare type OperationCompleteEvent = {
  state: number	//Indicates the outcome of a completed operation: Success, Cancelled, or Failed.
}

export declare type PointF = {
  (x?: number, y?: number): PointF
  distanceTo(point: PointF): number	//Get the distance from one point to another point
  x: number	//Get/Set the x value of a point
  y: number	//Get/Set the y value of a point
}

export declare type PointKeyframe = {
  value: {value: PointF}
  position: TickTime	//Get/Set position of a keyframe
}

export declare type ProjectStatic = {
  createProject(path: string): Promise<Project>	//Create a new project
  open(path: string, openProjectOptions?: OpenProjectOptions): Promise<Project>	//Open a project
  getActiveProject(): Promise<Project>	//Currently active project.
  getProject(projectGuid: Guid): Project	//Get project referenced by given UID
}

export declare type Project = {
  getActiveSequence(): Promise<Sequence>	//Get the active sequence of the project
  setActiveSequence(sequence: Sequence): Promise<boolean>	//Set the active sequence of the project
  createSequence(name: string, presetPath?: string): Promise<Sequence>	//Create a new sequence with the default preset path - Parameter presetPath is deprecated, instead use createSequenceWithPresetPath()
  createSequenceFromMedia(name: string, clipProjectItems?: ClipProjectItem[], targetBin?: ProjectItem): Promise<Sequence>	//Create a new sequence with a given name and medias
  getColorSettings(): Promise<ProjectColorSettings>	//Get project color settings object
  deleteSequence(sequence: Sequence): Promise<boolean>	//Delete a given sequence from the project
  getInsertionBin(): Promise<ProjectItem>	//Get current insertion bin
  openSequence(sequence: Sequence): Promise<boolean>	//Open a sequence and return true if successful.
  importSequences(projectPath: string, sequenceIds?: Guid[]): Promise<boolean>
  importAEComps(aepPath: string, compNames: string[], TargetBin?: ProjectItem): Promise<boolean>
  importAllAEComps(aepPath: string, TargetBin?: ProjectItem): Promise<boolean>
  importFiles(filePaths: string[], suppressUI?: boolean, targetBin?: ProjectItem, asNumberedStills?: boolean): Promise<boolean>	//Import files in root/target bin of the project
  close(closeProjectOptions?: CloseProjectOptions): Promise<boolean>	//Close a project
  save(): Promise<boolean>	//Save the project
  saveAs(path: string): Promise<boolean>	//Save the project at the provided path
  getSequence(guid: Guid): Sequence	//Get sequence by id from the project
  getSequences(): Promise<Sequence[]>	//Get an array of all sequences in this project.
  getRootItem(): Promise<FolderItem>	//The root item of the project which contains all items of the project on the lowest level.
  pauseGrowing(pause: boolean): Promise<boolean>	//Pause growing of files instead swap the files
  executeTransaction(callback: (compoundAction: CompoundAction) => void, undoString?: string): boolean	//Execute undoable transaction by passing compound action
  lockedAccess(callback: () => void): void	//Get a read/upgrade locked access to Project, project state will not change during the execution of callback function. Can call executeTransaction while having locked access.
  guid: Guid	//The unique identifier of the project.
  name: string	//The project name.
  path: string	//The absolute file path to the project file.
}

export declare type ProjectClosedEventStatic = {
  EVENT_CLOSED: string	//Event occurs when project was closed.
}

export declare type ProjectClosedEvent = {
  name: string	//The project name.
  path: string	//The absolute file path to the project file.
  id: string	//The unique identifier of the project.
}

export declare type ProjectColorSettings = {
  getSupportedGraphicsWhiteLuminances(): Promise<number[]>	//Get all the graphics white luminance as array of values
  getGraphicsWhiteLuminance(): Promise<number>	//Get the graphics white luminance value
}

export declare type ProjectEventStatic = {
  EVENT_OPENED: string	//Event occurs when project was opened.
  EVENT_ACTIVATED: string	//Event occurs when the active project has changed
  EVENT_DIRTY: string	//Event occurs when the project dirty state changed.
}

export declare type ProjectEvent = {
  name: string	//The project name.
  path: string	//The absolute file path to the project file.
  id: string	//The unique identifier of the project.
  project: Project	//The project object.
}

export declare type ProjectItemStatic = {
  cast(item: FolderItem | ClipProjectItem): ProjectItem	//Cast FolderItem or ClipProjectItem in to ProjectItem
}

export declare type ProjectItem = {
  createSetNameAction(inName: string): Action	//Returns action that renames projectItem
  getParent(): Promise<ProjectItem>	//Get the parent project item of this project item.
  getProject(): Promise<Project>	//Get the parent Project of this projectItem.
  name: string	//The name of this project item.
}

export declare type ProjectItemSelection = {
  getItems(): Promise<ProjectItem[]>	//Get the project items that is represented by this selection.
}

export declare type ProjectSettingsStatic = {
  createSetScratchDiskSettingsAction(project: Project, scratchDiskSettings: ScratchDiskSettings): Action	//Returns an action which sets ScratchDiskSetting
  getScratchDiskSettings(project: Project): Promise<ScratchDiskSettings>	//Returns project ScratchDiskSettings
  getIngestSettings(project: Project): Promise<IngestSettings>	//Returns project ingest settings
  createSetIngestSettingsAction(project: Project, ingestSettings: IngestSettings): Action	//Returns an action which sets IngestSettings
}

export declare type ProjectSettings = {
}

export declare type ProjectUtilsStatic = {
  getSelection(project: Project): Promise<ProjectItemSelection>	//Get array of selected project items in project view
  getProjectViewIds(): Promise<Guid[]>	//Get array of project view ids
  getProjectFromViewId(guid: Guid): Promise<Project>	//Get project based on input view guid
  getSelectionFromViewId(guid: Guid): Promise<ProjectItemSelection>	//Get array of selected projectItem based on input view guid
}

export declare type ProjectUtils = {
}

export declare type PropertiesStatic = {
  getProperties(propertyOwnerObject: Project | Sequence): Promise<Properties>	//Return Property Owner Object
  PROPERTY_PERSISTENT: number	//Property is persistent in backend and shared across cloud project.
  PROPERTY_NON_PERSISTENT: number	//Property is not persisted and will be cleared when the project closes.
}

export declare type Properties = {
  getValueAsInt(name: string): number	//Get named value as integer number
  getValueAsFloat(name: string): number	//Get named value as float number
  getValueAsBool(name: string): boolean	//Get named value as boolean
  getValue(name: string): string	//Get named value in native string form
  createSetValueAction(name: string, value: boolean | string | number, persistenceFlag: Constants.PropertyType): Action	//Create an action to set a named value through scripting. The parameters are <name, value (number, boolean or string), persistence flag>. This method can fail if e.g. the underlying properties object does not support action based setting of properties.
  hasValue(name: string): boolean	//Check if a named value exists under this name.
  createClearValueAction(name: string): Action	//Create an action to clear the value with the given name. This method can fail if e.g. the underlying properties object does not support action based setting of properties.
}

export declare type RectF = {
  (): RectF
  width: number	//Get/Set the width of a rect
  height: number	//Get/Set the height of a rect
}

export declare type ScratchDiskSettingsStatic = {
  FOLDERTYPE_CAPTURE: string	//Folder Type: CAPTURED
  FOLDERTYPE_VIDEO_CAPTURE: string	//Folder Type: VIDEOCAPTURE
  FOLDERTYPE_AUDIO_CAPTURE: string	//Folder Type: AUDIOCAPTURE
  FOLDERTYPE_VIDEO_PREVIEW: string	//Folder Type: VIDEOPREVIEW
  FOLDERTYPE_AUDIO_PREVIEW: string	//Folder Type: AUDIOPREVIEW
  FOLDERTYPE_AUTO_SAVE: string	//Folder Type: AUTOSAVE
  FOLDERTYPE_CCL_LIBRARIES: string	//Folder Type: CCLLIBRARIES
  FOLDERTYPE_CAPSULE_MEDIA: string	//Folder Type: CAPSULEMEDIA
  FOLDER_SAME_AS_PROJECT: string	//Folder: SAMEASPROJECT
  FOLDER_MY_DOCUMNETS: string	//Folder: MYDOCUMNETS
}

export declare type ScratchDiskSettings = {
  setScratchDiskPath(ScratchDiskType: Constants.ScratchDiskFolderType, ScratchDiskValue: Constants.ScratchDiskFolder): boolean	//Sets project ScratchDisk Path
  getScratchDiskPath(ScratchDiskType: Constants.ScratchDiskFolderType): string	//Gets the scratchDisk location for specific disktype - may return symbolic paths for reserved types like 'MyDocuments'
}

export declare type SequenceStatic = {
}

export declare type Sequence = {
  getSequenceVideoTimeDisplayFormat(): Promise<TimeDisplay>	//Get video time display format of this sequence
  getSequenceAudioTimeDisplayFormat(): Promise<TimeDisplay>	//Get audio time display format of this sequence
  getPlayerPosition(): Promise<TickTime>	//Get the player's current position
  setPlayerPosition(positionTime?: TickTime): Promise<boolean>	//Set the player's current position
  clearSelection(): Promise<boolean>	//Clears TrackItem Selection
  setSelection(trackItemSelection: TrackItemSelection): Promise<boolean>	//Updates sequence selection using the given track item selection.
  getVideoTrackCount(): Promise<number>	//Get video track count from this sequence
  getAudioTrackCount(): Promise<number>	//Get audio track count from this sequence
  getCaptionTrackCount(): Promise<number>	//Get caption track count from this sequence
  getVideoTrack(trackIndex: number): Promise<VideoTrack>	//Get video track from track index
  getAudioTrack(trackIndex: number): Promise<AudioTrack>	//Get audio track from track index
  getCaptionTrack(trackIndex: number): Promise<CaptionTrack>	//Get caption track from track index
  getSettings(): Promise<SequenceSettings>	//Get sequence settings object
  createSetSettingsAction(sequenceSettings: SequenceSettings): Action	//Returns action that set sequence settings
  createCloneAction(): Action	//Creates an action to clone the given sequence
  createSubsequence(ignoreTrackTargeting?: boolean): Promise<Sequence>	//Returns a new sequence, which is a sub-sequence of the existing sequence
  isDoneAnalyzingForVideoEffects(): Promise<boolean>	//Returns whether or not the sequence is done analyzing for video effects
  getZeroPoint(): Promise<TickTime>	//Time representing the zero point of the sequence.
  getEndTime(): Promise<TickTime>	//Time representing the end of the sequence
  getInPoint(): Promise<TickTime>	//Get time representing the inPoint of sequence.
  getOutPoint(): Promise<TickTime>	//Get time representing the inPoint of sequence.
  createSetInPointAction(tickTime: TickTime): Action	//Create SetInPointAction for sequence
  createSetZeroPointAction(tickTime: TickTime): Action	//Create an action to set an InPoint for the sequence
  createSetOutPointAction(tickTime: TickTime): Action	//Create SetOutPointAction for sequence
  getProjectItem(): Promise<ProjectItem>	//Get the associated projectItem of the sequence.
  getSelection(): Promise<TrackItemSelection>	//Returns the current selection group of the sequence.
  getFrameSize(): Promise<RectF>	//Gets the size of the frame
  getTimebase(): Promise<string>	//Gets the time base of sequence
  guid: Guid	//The unique identifier of the sequence.
  name: string	//The sequence name.
}

export declare type SequenceEditorStatic = {
  getEditor(sequenceObject: Sequence): SequenceEditor	//Get Sequence Editor reference for editing the sequence timeline
  getInstalledMogrtPath(): Promise<string>	//Get local directory path to adobe mogrt files
}

export declare type SequenceEditor = {
  createRemoveItemsAction(trackItemSelection: TrackItemSelection, ripple: boolean, mediaType: Constants.MediaType, shiftOverLapping?: boolean): Action	//Create remove action for sequence
  createInsertProjectItemAction(projectItem: ProjectItem, time: TickTime, videoTrackIndex: number, audioTrackIndex: number, limitShift: boolean): Action	//Create insert ProjectItem into Sequence Action
  createOverwriteItemAction(projectItem: ProjectItem, time: TickTime, videoTrackIndex: number, audioTrackIndex: number): Action	//Create overwrite Sequence with ProjectItem Action
  createCloneTrackItemAction(trackItem: VideoClipTrackItem | AudioClipTrackItem, timeOffset: TickTime, videoTrackVerticalOffset: number, audioTrackVerticalOffset: number, alignToVideo: boolean, isInsert: boolean): Action	//Duplicate trackItem using an insert or overwrite edit method to a destination track. Target track and start time of trackItem is determined using an offset value from the original trackItem position.
  insertMogrtFromPath(inMGTPath: string, inTime: TickTime, inVideoTrackIndex: number, inAudioTrackIndex: number): (VideoClipTrackItem | AudioClipTrackItem)[]	//Insert input MGT into sequence with time and index defined
  insertMogrtFromLibrary(inLibraryName: string, inElementName: string, inTime: TickTime, inVideoTrackIndex: number, inAudioTrackIndex: number): (VideoClipTrackItem | AudioClipTrackItem)[]	//Insert input MGT into sequence with time and index defined
}

export declare type SequenceSettingsStatic = {
  PAR_SQUARE: string	//Square Pixels (1.0)
  PAR_DVNTSC: string	//DV NTSC (0.9091)
  PAR_DVNTSCWide: string	//DV NTSC Widescreen 16:9 (1.2121)
  PAR_DVPAL: string	//DV PAL (1.0940)
  PAR_DVPALWide: string	//DV PAL Widescreen 16:9 (1.4587)
  PAR_Anamorphic: string	//Anamorphic 2:1 (2.0)
  PAR_HDAnamorphic1080: string	//HD Anamorphic 1080 (1.333)
  PAR_DVCProHD: string	//DVCPRO HD (1.5)
  VIDEO_FIELDTYPE_PROGRESSIVE: number	//Video field type progressive
  VIDEO_FIELDTYPE_UPPER_FIRST: number	//Video field type upper first
  VIDEO_FIELDTYPE_LOWER_FIRST: number	//Video field type lower first
  VIDEO_DISPLAY_FORMAT_23976: number	//23.976 fps TimeCode
  VIDEO_DISPLAY_FORMAT_25: number	//25 fps TimeCode
  VIDEO_DISPLAY_FORMAT_2997: number	//29.97 fps TimeCode
  VIDEO_DISPLAY_FORMAT_2997_NON_DROP: number	//29.97 fps Non-Drop-Frame TimeCode
  VIDEO_DISPLAY_FORMAT_16mm: number	//Feet+Frame 16mm
  VIDEO_DISPLAY_FORMAT_35mm: number	//Feet+Frame 35mm
  VIDEO_DISPLAY_FORMAT_FRAMES: number	//Frames
  AUDIO_CHANNEL_TYPE_MONO: number	//Audio Channel Type Mono
  AUDIO_CHANNEL_TYPE_STEREO: number	//Audio Channel Type Stereo
  AUDIO_CHANNEL_TYPE_51: number	//Audio Channel Type 5.1
  AUDIO_CHANNEL_TYPE_MULTI: number	//Audio Channel Type Multi
  AUDIO_DISPLAY_FORMAT_SAMPLE_RATE: number	//Audio Display format: Audio Sample Timecode
  AUDIO_DISPLAY_FORMAT_MILISECONDS: number	//Audio Display format miliseconds
}

export declare type SequenceSettings = {
  getMaximumBitDepth(): Promise<boolean>	//Find if maximum bit depth is set
  setMaximumBitDepth(useMaxBitDepth: boolean): Promise<boolean>	//Set maximum bit depth to true/false
  getMaxRenderQuality(): Promise<boolean>	//Find if maximum render quality is set
  setMaxRenderQuality(useMaxRenderQuality: boolean): Promise<boolean>	//Set maximum render quality to true/false
  getAudioChannelCount(): Promise<number>	//Get number of channels in the sequence
  getAudioChannelType(): Promise<number>	//Get Audio channel type of sequence. Could be 0 (Mono), 1 (Stereo), 2 (5.1), or 3 (multichannel)
  getAudioDisplayFormat(): Promise<TimeDisplay>	//Get Audio display format
  setAudioDisplayFormat(audioDisplay: TimeDisplay): Promise<boolean>	//Set audio display format of sequence.
  getAudioSampleRate(): Promise<FrameRate>	//Get audio sample rate
  setAudioSampleRate(inRate: FrameRate): Promise<boolean>	//Set audio sample rate
  getVideoDisplayFormat(): Promise<TimeDisplay>	//Get Video display format
  setVideoDisplayFormat(audioDisplay: TimeDisplay): Promise<boolean>	//Set video display format of sequence
  getVideoFieldType(): Promise<number>	//Get video field type in the sequence
  setVideoFieldType(videoFiledType: number): Promise<boolean>	//Set video field type in sequence
  getVideoFrameRect(): Promise<RectF>	//Get video frame rect in the sequence
  setVideoFrameRect(inVideoFrameRect: RectF): Promise<boolean>	//Set video frame rect in sequence
  getVideoPixelAspectRatio(): Promise<string>	//Get Video display format
  setVideoPixelAspectRatio(inPixelAspectRatio: string): Promise<boolean>	//Set video display format of sequence
  getCompositeInLinearColor(): Promise<boolean>	//Get if composite in linear color is checked
  setCompositeInLinearColor(useCompositeInLinearColor: boolean): Promise<boolean>	//Set if composite in linear color is checked
  getEditingMode(): Promise<string>	//Get editing mode of sequence
  setEditingMode(inEditingModeName: string): Promise<boolean>	//Set editing mode of sequence
  getPreviewFileFormat(): Promise<string>	//Get preview file format of sequence
  setPreviewFileFormat(inPreviewCodec: string): Promise<boolean>	//Set preview file format of sequence
  getPreviewCodec(): Promise<string>	//Get preview codec of sequence
  setPreviewCodec(inPreviewCodec: string): Promise<boolean>	//Set preview codec of sequence
  getPreviewFrameRect(): Promise<RectF>	//Get preview video frame rect in the sequence
  setPreviewFrameRect(inPreviewVideoRect: RectF): Promise<boolean>	//Set preview video frame rect in sequence
}

export declare type SequenceUtilsStatic = {
  performSceneEditDetectionOnSelection(clipOperation: string, trackItemSelection: TrackItemSelection): Promise<boolean>	//Performs cut detection on the sequence selection
  SEQUENCE_OPERATION_APPLYCUT: string	//ApplyCuts
  SEQUENCE_OPERATION_CREATEMARKER: string	//CreateMarkers
  SEQUENCE_OPERATION_CREATESUBCLIP: string	//CreateSubclips
}

export declare type SequenceUtils = {
}

export declare type SnapEventStatic = {
  EVENT_SNAP_TO_KEYFRAME: string	//Event occurs a user scrub on timeline over keyframes when shift key is applied.
  EVENT_SNAP_TO_TRACKITEM: string	//Event occurs a user scrub on timeline and snaps to various track item alignments.
  EVENT_SNAP_TO_GUIDES: string	//Event occurs object is snapped to guildelines when holding the Cmd/Ctrl key.
  EVENT_SNAP_RAZOR_TO_PLAYHEAD: string	//Event occurs when the razor tool hovers over the playhead and snaps into position for a cut.
  EVENT_SNAP_RAZOR_TO_MARKER: string	//Event occurs when the razor tool hovers over the all types of markers and snaps into position for a cut.
}

export declare type SnapEvent = {
}

export declare type SourceMonitorStatic = {
  openFilePath(filePath: string): Promise<boolean>	//Open the item at the specified path and send to the Source Monitor for preview
  openProjectItem(projectItem: ProjectItem): Promise<boolean>	//Open input projectItem on Source Monitor
  closeClip(): Promise<boolean>	//Close clip on Source Monitor
  closeAllClips(): Promise<boolean>	//Close all clips on Source Monitor
  getPosition(): Promise<TickTime>	//Get position of source monitor in time
  play(speed?: number): Promise<boolean>	//Play clip at source monitor with input speed
  getProjectItem(): Promise<ProjectItem>	//Get projectItem at source monitor
}

export declare type SourceMonitor = {
}

export declare type TickTimeStatic = {
  createWithFrameAndFrameRate(frameCount: number, frameRate: FrameRate): TickTime	//Constructs a TickTime object with a frame and a frame rate.
  createWithSeconds(seconds: number): TickTime	//Constructs a TickTime object with seconds.
  createWithTicks(ticks: string): TickTime	//Constructs a TickTime object with ticks as a string.
  TIME_ZERO: TickTime	//Zero Tick Time Constant
  TIME_ONE_SECOND: TickTime	//One Second Tick Time Constant
  TIME_ONE_MINUTE: TickTime	//One Second Tick Time Constant
  TIME_ONE_HOUR: TickTime	//One Hour Tick Time Constant
  TIME_MAX: TickTime	//Max Tick Time Constant
  TIME_MIN: TickTime	//Min Tick Time Constant
  TIME_INVALID: TickTime	//Invalid Tick Time Constant
}

export declare type TickTime = {
  (): TickTime
  equals(tickTime: TickTime): boolean	//Returns true if the given TickTime is equal to the TickTime object
  alignToNearestFrame(frameRate: FrameRate): TickTime	//AlignToNearestFrame will return a TickTime that is aligned to the nearest frame boundary greater than or less than the given time, for a given frame rate by rounding any fractional portion.
  alignToFrame(frameRate: FrameRate): TickTime	//alignToFrame will return a TickTime that is aligned to the nearest frame boundary less than the given time, for a given frame rate by rounding any fractional portion.
  add(tickTime: TickTime): TickTime	//Add another TickTime to this one and return it. This TickTime is not modified.
  subtract(tickTime: TickTime): TickTime	//Subtract another TickTime from this one and return it. This TickTime is not modified.
  multiply(factor: number): TickTime	//Multiply this TickTime with a factor and return it. This TickTime is not modified.
  divide(divisor: number): TickTime	//Divide this TickTime by a divisor and return it. In case of a division by zero, TIME_INVALID is returned. This TickTime is not modified.
  seconds: number	//Get the TickTime in seconds
  ticks: string	//Get the TickTime in ticks as a string
  ticksNumber: number	//Get the TickTime in ticks as a number
}

export declare type TimeDisplay = {
  type: number	//Read/Write property to get/set the time display type numeric code
}

export declare type TrackItemSelectionStatic = {
  createEmptySelection(callback0: (selection: TrackItemSelection) => void): boolean	//Create empty selection
}

export declare type TrackItemSelection = {
  addItem(trackItem: VideoClipTrackItem | AudioClipTrackItem, skipDuplicateCheck?: boolean): boolean	//Add a track item to this selection
  removeItem(trackItem: VideoClipTrackItem | AudioClipTrackItem): boolean	//Remove a track item from this selection
  getTrackItems(): Promise<(VideoClipTrackItem | AudioClipTrackItem)[]>	//return list of trackItems inside of trackItemSelection
}

export declare type TransitionFactoryStatic = {
  createVideoTransition(matchName: string): VideoTransition	//Creates a new video filter component based on the input matchName
  getVideoTransitionMatchNames(): Promise<string[]>	//Return a promise which will be fullfilled with an array of video transition matchnames
}

export declare type TransitionFactory = {
}

export declare type UtilsStatic = {
  isAEInstalled(): Promise<boolean>	//Check if AE is installed.
}

export declare type Utils = {
}

export declare type VideoClipTrackItemStatic = {
  TRACKITEMTYPE_EMPTY: number	//Empty Track Item Type
  TRACKITEMTYPE_CLIP: number	//Clip Track Item Type
  TRACKITEMTYPE_TRANSITION: number	//Transition Track Item Type
  TRACKITEMTYPE_PREVIEW: number	//Previe Track Item Type
  TRACKITEMTYPE_FEEDBACK: number	//Feedback Track Item Type
}

export declare type VideoClipTrackItem = {
  createAddVideoTransitionAction(videoTransition: VideoTransition, addTransitionOptionsProperties?: AddTransitionOptions): Action	//Create add transition action for sequence
  createRemoveVideoTransitionAction(transitionPosition?: Constants.TransitionPosition): Action	//Returns true if trackItem has transition
  getMatchName(): Promise<string>	//Returns the value of internal matchname for this trackItem
  getName(): Promise<string>	//Returns the display name for trackItem
  getIsSelected(): Promise<boolean>	//Returns if trackItem is selected or not
  getSpeed(): Promise<number>	//Returns the value of speed of the trackItem
  isAdjustmentLayer(): Promise<boolean>	//Returns true if the trackitem is an adjustment layer
  isSpeedReversed(): Promise<number>	//Returns true if the trackitem is reversed
  createMoveAction(tickTime: TickTime): Action	//Returns an action that moves the inPoint of the track item to a new time, by shifting it by a number of seconds.
  getInPoint(): Promise<TickTime>	//Returns a TickTime object representing the track item in point relative to the start time of the project item referenced by this track item.
  getOutPoint(): Promise<TickTime>	//Returns a TickTime object representing the track item out point relative to the start time of the project item referenced by this track item.
  createSetInPointAction(tickTime: TickTime): Action	//Create SetInPointAction for setting the track item in point relative to the start time of the project item referenced by this track item
  createSetOutPointAction(tickTime: TickTime): Action	//Create SetOutPointAction for setting the track item out point relative to the start time of the project item referenced by this track item
  getStartTime(): Promise<TickTime>	//Returns a TickTime object representing the starting sequence time of this track item relative to the sequence start time.
  getEndTime(): Promise<TickTime>	//Returns a TickTime object representing the ending sequence time of this track item relative to the sequence start time.
  createSetStartAction(tickTime: TickTime): Action	//Create set start time action for sequence
  createSetEndAction(tickTime: TickTime): Action	//Create set end time action for sequence
  getDuration(): Promise<TickTime>	//Returns timecode representing the duration of this track item relative to the sequence start.
  getType(): Promise<number>	//Index representing the type of this track item.
  isDisabled(): Promise<boolean>	//Returns true if trackitem is muted/disabled
  createSetDisabledAction(disabled: boolean): Action	//Returns an action that enables/disables the trackItem 
  createSetNameAction(inName: string): Action	//Returns an action that renames the trackItem
  getMediaType(): Promise<Guid>	//Returns UUID representing the underlying media type of this track item
  getTrackIndex(): Promise<number>	//Index representing the track index of the track this track item belongs to
  getProjectItem(): Promise<ProjectItem>	//Returns the project item for this track item.
  getComponentChain(): Promise<VideoComponentChain>	//Returns VideoComponentChain
}

export declare type VideoComponentChainStatic = {
}

export declare type VideoComponentChain = {
  createInsertComponentAction(component: Component | VideoFilterComponent, componentInsertionIndex: number): Action	//Creates and returns an insert component action
  createAppendComponentAction(component: Component | VideoFilterComponent): Action	//Creates and returns an append component action
  createRemoveComponentAction(component: Component | VideoFilterComponent): Action	//Creates and returns an remove component action
  getComponentAtIndex(componentIndex: number): Component	//Returns the component at the given index
  getComponentCount(): number	//Gets the number of components in the component chain
}

export declare type VideoFilterComponentStatic = {
}

export declare type VideoFilterComponent = {
}

export declare type VideoFilterFactoryStatic = {
  createComponent(matchName: string): Promise<VideoFilterComponent>	//Creates a new video filter component based on the input matchName
  getMatchNames(): Promise<string[]>	//Returns an array of video filter matchNames
  getDisplayNames(): Promise<string[]>	//Returns an array of video filter display names
}

export declare type VideoFilterFactory = {
}

export declare type VideoTrackStatic = {
  EVENT_TRACK_CHANGED: string	//Event Object for Track changed
  EVENT_TRACK_INFO_CHANGED: string	//Event Object for Track Info Changed
  EVENT_TRACK_LOCK_CHANGED: string	//Event Object for Track Lock Changed
}

export declare type VideoTrack = {
  setMute(mute: boolean): Promise<boolean>	//sets the mute state of the track to muted/unmuted
  getMediaType(): Promise<Guid>	//UUID representing the underlying media type of this track
  getIndex(): Promise<number>	//Index representing the track index of this track within the track group.
  isMuted(): Promise<boolean>	//Get mute state of the track
  getTrackItems(trackItemType: Constants.TrackItemType, includeEmptyTrackItems: boolean): VideoClipTrackItem[]	//Returns array of VideoClipTrackItem from the track item type
  name: string	//Get the name of the track
  id: number	//The ID of the track within the TrackGroup
}

export declare type VideoTransitionStatic = {
  TRANSITIONPOSITION_START: number	//TransitionPosition: START
  TRANSITIONPOSITION_END: number	//TransitionPosition: END
}

export declare type VideoTransition = {
}

export declare type EventManagerStatic = {
  addEventListener(target: Project | Sequence | VideoTrack | AudioTrack | EncoderManager, eventName: string | Constants.SnapEvent | Constants.ProjectEvent | Constants.SequenceEvent | Constants.OperationCompleteEvent, eventHandler: (event?: Object) => void, inCapturePhase?: boolean): void	//add event listener to target object
  removeEventListener(target: Project | Sequence | VideoTrack | AudioTrack | EncoderManager, eventName: string | Constants.SnapEvent | Constants.ProjectEvent | Constants.SequenceEvent | Constants.OperationCompleteEvent, eventHandler: (event?: Object) => void): void	//remove event listener from target object
  addGlobalEventListener(eventName: string | Constants.SnapEvent | Constants.ProjectEvent | Constants.SequenceEvent | Constants.OperationCompleteEvent, eventHandler: (event?: Object) => void, inCapturePhase?: boolean): void	//add global event listener
  removeGlobalEventListener(eventName: string | Constants.SnapEvent | Constants.ProjectEvent | Constants.SequenceEvent | Constants.OperationCompleteEvent, eventHandler: (event?: Object) => void): void	//remove global event listener
}

export declare type EventManager = {
}


export namespace Constants {
	export enum MediaType {
		ANY,
		DATA,
		VIDEO,
		AUDIO
	}

	export enum ContentType {
		ANY,
		SEQUENCE,
		MEDIA
	}

	export enum TransitionPosition {
		START,
		END
	}

	export enum TrackItemType {
		EMPTY,
		CLIP,
		TRANSITION,
		PREVIEW,
		FEEDBACK
	}

	export enum ProjectEvent {
		OPENED,
		CLOSED,
		DIRTY,
		ACTIVATED,
		PROJECT_ITEM_SELECTION_CHANGED
	}

	export enum InterpolationMode {
		BEZIER,
		HOLD,
		LINEAR,
		TIME,
		TIME_TRANSITION_END,
		TIME_TRANSITION_START
	}

	export enum SequenceOperation {
		APPLYCUT,
		CREATEMARKER,
		CREATESUBCLIP
	}

	export enum PropertyType {
		PERSISTENT,
		NON_PERSISTENT
	}

	export enum SequenceEvent {
		ACTIVATED,
		CLOSED,
		SELECTION_CHANGED
	}

	export enum VideoTrackEvent {
		TRACK_CHANGED,
		INFO_CHANGED,
		LOCK_CHANGED
	}

	export enum AudioTrackEvent {
		TRACK_CHANGED,
		INFO_CHANGED,
		LOCK_CHANGED
	}

	export enum EncoderEvent {
		RENDER_COMPLETE,
		RENDER_ERROR,
		RENDER_CANCEL,
		RENDER_QUEUE,
		RENDER_PROGRESS
	}

	export enum ScratchDiskFolderType {
		CAPTURE,
		AUDIO_CAPTURE,
		VIDEO_CAPTURE,
		AUDIO_PREVIEW,
		VIDEO_PREVIEW,
		AUTO_SAVE,
		CCL_LIBRARIES,
		CAPSULE_MEDIA
	}

	export enum ScratchDiskFolder {
		SAME_AS_PROJECT,
		MY_DOCUMENTS
	}

	export enum MetadataType {
		INTEGER,
		REAL,
		TEXT,
		BOOLEAN
	}

	export enum ExportType {
		QUEUE_TO_AME,
		QUEUE_TO_APP,
		IMMEDIATELY
	}

	export enum PreferenceKey {
		AUTO_PEAK_GENERATION,
		IMPORT_WORKSPACE,
		SHOW_QUICKSTART_DIALOG
	}

	export enum SnapEvent {
		KEYFRAME,
		RAZOR_PLAYHEAD,
		RAZOR_MARKER,
		TRACKITEM,
		GUIDES
	}

	export enum OperationCompleteEvent {
		CLIP_EXTEND_REACHED,
		EFFECT_DROP_COMPLETE,
		EXPORT_MEDIA_COMPLETE,
		GENERATIVE_EXTEND_COMPLETE,
		IMPORT_MEDIA_COMPLETE
	}

	export enum OperationCompleteState {
		SUCCESS,
		CANCELLED,
		FAILED
	}

	export enum PixelAspectRatio {
		SQUARE,
		DVNTSC,
		DVNTSCWide,
		DVPAL,
		DVPALWide,
		Anamorphic,
		HDAnamorphic1080,
		DVCProHD
	}

	export enum VideoFieldType {
		PROGRESSIVE,
		UPPER_FIRST,
		LOWER_FIRST
	}

	export enum VideoDisplayFormatType {
		FPS_23_976,
		FPS_25,
		FPS_29_97,
		FPS_29_97_NON_DROP,
		FEET_FRAME_16mm,
		FEET_FRAME_35mm,
		FRAMES
	}

	export enum AudioChannelType {
		MONO,
		STEREO,
		SURROUND_51,
		MULTI
	}

	export enum AudioDisplayFormatType {
		SAMPLE_RATE,
		MILLISECONDS
	}
}

export default premierepro
```

## File: .gitignore
```
build-html
```

## File: types.d.ts
```typescript
export declare type premierepro = {
  AppPreference: AppPreferenceStatic
  AudioClipTrackItem: AudioClipTrackItemStatic
  AudioComponentChain: AudioComponentChainStatic
  AudioFilterComponent: AudioFilterComponentStatic
  AudioFilterFactory: AudioFilterFactoryStatic
  AudioTrack: AudioTrackStatic
  CaptionTrack: CaptionTrackStatic
  ClipProjectItem: ClipProjectItemStatic
  EncoderManager: EncoderManagerStatic
  Exporter: ExporterStatic
  FolderItem: FolderItemStatic
  FrameRate: FrameRateStatic
  Guid: GuidStatic
  Keyframe: KeyframeStatic
  Marker: MarkerStatic
  Markers: MarkersStatic
  Metadata: MetadataStatic
  OperationCompleteEvent: OperationCompleteEventStatic
  Project: ProjectStatic
  ProjectClosedEvent: ProjectClosedEventStatic
  ProjectEvent: ProjectEventStatic
  ProjectItem: ProjectItemStatic
  ProjectSettings: ProjectSettingsStatic
  ProjectUtils: ProjectUtilsStatic
  Properties: PropertiesStatic
  ScratchDiskSettings: ScratchDiskSettingsStatic
  Sequence: SequenceStatic
  SequenceEditor: SequenceEditorStatic
  SequenceSettings: SequenceSettingsStatic
  SequenceUtils: SequenceUtilsStatic
  SnapEvent: SnapEventStatic
  SourceMonitor: SourceMonitorStatic
  TickTime: TickTimeStatic
  TrackItemSelection: TrackItemSelectionStatic
  TransitionFactory: TransitionFactoryStatic
  Utils: UtilsStatic
  VideoClipTrackItem: VideoClipTrackItemStatic
  VideoComponentChain: VideoComponentChainStatic
  VideoFilterComponent: VideoFilterComponentStatic
  VideoFilterFactory: VideoFilterFactoryStatic
  VideoTrack: VideoTrackStatic
  VideoTransition: VideoTransitionStatic
  EventManager: EventManagerStatic
  AddTransitionOptions: AddTransitionOptions
  Constants: typeof Constants
}

export declare type Action = {
}

export declare type AddTransitionOptions = {
  (): AddTransitionOptions
  setApplyToStart(applyToStart: boolean): AddTransitionOptions	//Set whether to apply transition to the start or end of trackitem
  setForceSingleSided(forceSingleSided: boolean): AddTransitionOptions	//Set whether transition should be applied to one/both sides
  setTransitionAlignment(transitionAlignment: number): AddTransitionOptions	//Sets the transitionAlignment of the transition
  setDuration(tickTime: TickTime): AddTransitionOptions	//Sets the duration of transition
  applyToStart: boolean	//Get whether to apply transition to the start or end of trackitem
  forceSingleSided: boolean	//Get whether transition should be applied to one/both sides
  transitionAlignment: number	//Gets the transitionAlignment of transition
  duration: TickTime	//Gets the duration of transition
}

export declare type AppPreferenceStatic = {
  setValue(key: Constants.PreferenceKey, value: boolean | string | number, persistenceFlag: Constants.PropertyType): boolean	//Set backend preference using given list of property keys. The parameters are <key, value (number, boolean or string), persistence flag>
  getValue(preferenceKey: Constants.PreferenceKey): string	//Get preference value in native string form
  KEY_AUTO_PEAK_GENERATION: string	//Preference string key used to modify auto-peak generation settings
  KEY_IMPORT_WORKSPACE: string	//Preference string key used to modify import workspace settings
  KEY_SHOW_QUICKSTART_DIALOG: string	//Preference string key used to modify show quickstart dialog settings
  PROPERTY_PERSISTENT: number	//Property is persistent in backend and shared across cloud project.
  PROPERTY_NON_PERSISTENT: number	//Property is not persisted and will be cleared when the project closes.
}

export declare type AppPreference = {
}

export declare type Application = {
  version: string
}

export declare type AudioClipTrackItemStatic = {
  TRACKITEMTYPE_EMPTY: number	//Empty Track Item Type
  TRACKITEMTYPE_CLIP: number	//Clip Track Item Type
  TRACKITEMTYPE_TRANSITION: number	//Transition Track Item Type
  TRACKITEMTYPE_PREVIEW: number	//Previe Track Item Type
  TRACKITEMTYPE_FEEDBACK: number	//Feedback Track Item Type
}

export declare type AudioClipTrackItem = {
  getMatchName(): Promise<string>	//Returns the value of internal matchname for this trackItem
  getName(): Promise<string>	//Returns the display name for trackItem
  getIsSelected(): Promise<boolean>	//Returns if trackItem is selected or not
  getSpeed(): Promise<number>	//Returns the value of speed of the trackItem
  isAdjustmentLayer(): Promise<boolean>	//Returns true if the trackitem is an adjustment layer
  isSpeedReversed(): Promise<number>	//Returns true if the trackitem is reversed
  createMoveAction(tickTime: TickTime): Action	//Returns an action that moves the inPoint of the track item to a new time, by shifting it by a number of seconds.
  getInPoint(): Promise<TickTime>	//Returns a TickTime object representing the track item in point relative to the start time of the project item referenced by this track item.
  getOutPoint(): Promise<TickTime>	//Returns a TickTime object representing the track item out point relative to the start time of the project item referenced by this track item.
  createSetInPointAction(tickTime: TickTime): Action	//Create SetInPointAction for setting the track item in point relative to the start time of the project item referenced by this track item
  createSetOutPointAction(tickTime: TickTime): Action	//Create SetOutPointAction for setting the track item out point relative to the start time of the project item referenced by this track item
  getStartTime(): Promise<TickTime>	//Returns a TickTime object representing the starting sequence time of this track item relative to the sequence start time.
  getEndTime(): Promise<TickTime>	//Returns a TickTime object representing the ending sequence time of this track item relative to the sequence start time.
  createSetStartAction(tickTime: TickTime): Action	//Create set start time action for sequence
  createSetEndAction(tickTime: TickTime): Action	//Create set end time action for sequence
  getDuration(): Promise<TickTime>	//Returns timecode representing the duration of this track item relative to the sequence start.
  getType(): Promise<number>	//Index representing the type of this track item.
  isDisabled(): Promise<boolean>	//Returns true if trackitem is muted/disabled
  createSetDisabledAction(disabled: boolean): Action	//Returns an action that enables/disables the trackItem 
  createSetNameAction(inName: string): Action	//Returns an action that renames the trackItem
  getMediaType(): Promise<Guid>	//Returns UUID representing the underlying media type of this track item
  getTrackIndex(): Promise<number>	//Index representing the track index of the track this track item belongs to
  getProjectItem(): Promise<ProjectItem>	//Returns the project item for this track item.
  getComponentChain(): Promise<AudioComponentChain>	//Returns AudioComponentChain
}

export declare type AudioComponentChainStatic = {
}

export declare type AudioComponentChain = {
  createInsertComponentAction(component: Component | AudioFilterComponent, componentInsertionIndex: number): Action	//Creates and returns an insert component action
  createAppendComponentAction(component: Component | AudioFilterComponent): Action	//Creates and returns an append component action
  createRemoveComponentAction(component: Component | AudioFilterComponent): Action	//Creates and returns an remove component action
  getComponentAtIndex(componentIndex: number): Component	//Returns the component at the given index
  getComponentCount(): number	//Gets the number of components in the component chain
}

export declare type AudioFilterComponentStatic = {
}

export declare type AudioFilterComponent = {
}

export declare type AudioFilterFactoryStatic = {
  createComponentByDisplayName(displayName: string, inAudioClipTrackItem: AudioClipTrackItem): Promise<AudioFilterComponent>	//Creates a new audio filter component based on the input display name and trackItem for applying the audio filter
  getDisplayNames(): Promise<string[]>	//Returns an array of audio filter displayNames
}

export declare type AudioFilterFactory = {
}

export declare type AudioTrackStatic = {
  EVENT_TRACK_CHANGED: string	//Event Object for Track changed
  EVENT_TRACK_INFO_CHANGED: string	//Event Object for Track Info Changed
  EVENT_TRACK_LOCK_CHANGED: string	//Event Object for Track Lock Changed
}

export declare type AudioTrack = {
  setMute(mute: boolean): Promise<boolean>	//sets the mute state of the track to muted/unmuted
  getMediaType(): Promise<Guid>	//UUID representing the underlying media type of this track
  getIndex(): Promise<number>	//Index representing the track index of this track within the track group.
  isMuted(): Promise<boolean>	//Get mute state of the track
  getTrackItems(trackItemType: Constants.TrackItemType, includeEmptyTrackItems: boolean): AudioClipTrackItem[]	//Returns array of AudioClipTrackItem from the track item type
  name: string	//Get the name of the track
  id: number	//The ID of the track within the TrackGroup
}

export declare type CaptionTrackStatic = {
}

export declare type CaptionTrack = {
  setMute(mute: boolean): Promise<boolean>	//sets the mute state of the track to muted/unmuted
  getMediaType(): Promise<Guid>	//UUID representing the underlying media type of this track
  getIndex(): Promise<number>	//Index representing the track index of this track within the track group.
  isMuted(): Promise<boolean>	//Get mute state of the track
  getTrackItems(trackItemType: number, includeEmptyTrackItems: boolean): []	//Returns the track items of the specified media type from the given track
  name: string	//Get the name of the track
  id: number	//The ID of the track within the TrackGroup
}

export declare type ClipProjectItemStatic = {
  cast(projectItem: ProjectItem): ClipProjectItem	//Cast ProjectItem in to ClipProjectItem
}

export declare type ClipProjectItem = {
  getInputLUTID(): Promise<string>	//Get Guid of Input LUT overridden on media
  createSetInputLUTIDAction(stringLUTID: string): Action	//Create action for setting Guid of Input LUT on media. This applies for Video Clips only.
  isSequence(): Promise<boolean>	//Returns true if the project item is a sequence
  canChangeMediaPath(): Promise<boolean>	//Returns true if Premiere Pro can change the path associated with this project item; otherwise, returns false
  isOffline(): Promise<boolean>	//Returns true if the media is offline
  canProxy(): Promise<boolean>	//Indicates whether it is possible to attach a proxy to this project item.
  getProxyPath(): Promise<string>	//Returns the proxy path if the project item has a proxy attached
  hasProxy(): Promise<boolean>	//Indicates whether a proxy has already been attached to the project item.
  attachProxy(mediaPath: string, isHiRes: boolean, inMakeAlternateLinkInTeamProjects?: boolean): Promise<boolean>	//Attach proxy or high resolution footage to projectItem and returns true if successful. Not undoable.
  findItemsMatchingMediaPath(matchString: string, ignoreSubclips?: boolean): Promise<ProjectItem[]>	//Returns array of project's items with media paths containing match string
  refreshMedia(): Promise<boolean>	//Updates representation of the media associated with the project item
  createSetOfflineAction(): Action	//Returns an action which sets the media offline
  getFootageInterpretation(): Promise<FootageInterpretation>	//Get the footage interpretation object for project item
  createSetFootageInterpretationAction(footageInterpretation: FootageInterpretation): Action	//Set the footage interpretation object for project item
  changeMediaFilePath(newPath: string, overrideCompatibilityCheck?: boolean): Promise<boolean>	//Change media file path of projectItem and returns true if successful. Not undoable.
  isMergedClip(): Promise<boolean>	//Returns true if the clip Project item is a merged clip
  isMulticamClip(): Promise<boolean>	//Returns true if the clip Project item is a multicam clip
  getEmbeddedLUTID(): Promise<string>	//Get GUID of LUT embedded in media
  createSetScaleToFrameSizeAction(): Action	//Returns an action which sets the scale to frame to true
  createSetNameAction(inName: string): Action	//Returns action that renames projectItem
  getParent(): Promise<ProjectItem>	//Get the parent project item of this project item.
  getProject(): Promise<Project>	//Get the parent Project of this projectItem.
  getContentType(): Promise<Constants.ContentType>	//Get content type of the Project item
  getSequence(): Promise<Sequence>	//Get the sequence of the Project item
  getInPoint(mediaType: Constants.MediaType): Promise<TickTime>	//Get the in point of the Project item
  getOutPoint(mediaType: Constants.MediaType): Promise<TickTime>	//Get the out point of the Project item
  getMediaFilePath(): Promise<string>	//Get the media file path of the Project item.
  getComponentChain(mediaType: Constants.MediaType): Promise<string>	//Get the media file path of the Project item.
  createSetInPointAction(tickTime: TickTime): Action	//Returns an action which Sets the in point of the Project item
  createSetOverridePixelAspectRatioAction(inNumerator: number, inDenominator: number): Action	//Returns an action which sets Override pixel aspect ratio
  createSetOverrideFrameRateAction(inOverriddenFrameRateValue: number): Action	//Returns an action which sets the override frame rate
  createSetOutPointAction(tickTime: TickTime): Action	//Returns an action which Sets the in point of the Project item
  createSetInOutPointsAction(inPoint: TickTime, outPoint: TickTime): Action	//Set the in or out point of the Project item
  createClearInOutPointsAction(): Action	//Create Clear the in or out point of the Project item action
  getMedia(): Promise<Media>	//Return media associated with clipProjectItem
  name: string	//The name of this project item.
}

export declare type CloseProjectOptions = {
  (): CloseProjectOptions
  setPromptIfDirty(promptIfDirty: boolean): CloseProjectOptions	//Set whether to prompt if a project is dirty on project open/close
  setShowCancelButton(showCancelButton: boolean): CloseProjectOptions	//Set whether to show the cancel button on project open/close
  setIsAppBeingPreparedToQuit(isAppBeingPreparedToQuit: boolean): CloseProjectOptions	//Set whether the app should be prepared to quit when open/closing a project
  setSaveWorkspace(isAppBeingPreparedToQuit: boolean): CloseProjectOptions	//Set whether to save your workspaces when opening/closing a project
  promptIfDirty: boolean	//Get whether a prompt is shown if a project is dirty on project open/close
  showCancelButton: boolean	//Get whether the cancel button is shown on project open/close
  isAppBeingPreparedToQuit: boolean	//Get whether the app is prepared to quit when open/closing a project
  saveWorkspace: boolean	//Get whether your workspaces are saved when opening/closing a project
}

export declare type Color = {
  (red?: number, green?: number, blue?: number, alpha?: number): Color
  equals(colorObject: Color): boolean	//Returns true if the given ColorObject is equal to this ColorObject
  red: number	//Read/Write property to get/set red value of color object
  green: number	//Read/Write property to get/set green value of color object
  blue: number	//Read/Write property to get/set blue value of color object
  alpha: number	//Read/Write property to get/set alpha value of color object
}

export declare type Component = {
  getParam(paramIndex?: number): ComponentParam	//Get a parameter from the component based on the given input index. Parameter indexes are zero-based, and the actual is defined exclusively by the component itself.
  getMatchName(): Promise<string>	//Returned Promise will be fullfilled with the value of internal matchname for this component
  getDisplayName(): Promise<string>	//Returned Promise will be fullfilled with the value of display name for this component
  getParamCount(): number	//Gets the number of param in the component
}

export declare type ComponentParam = {
  createKeyframe(inValue: number | string | boolean | PointF | Color): Keyframe	//Creates and returns a keyframe initialised with the ComponentParam's type and passed in value. This throws if the passed in value is not compatible with the component param type
  getValueAtTime(time: TickTime): Promise<number | string | boolean | PointF | Color>	//Gets the value of component Param at the given time
  findNearestKeyframe(inTime: TickTime, outTime: TickTime): Keyframe	//Find sthe nearest key for the given time
  findNextKeyframe(inTime: TickTime): Keyframe	//find the next keyframe for the given time
  findPreviousKeyframe(inTime: TickTime): Keyframe	//find the previous keyframe for the given time
  createRemoveKeyframeAction(inTime: TickTime, UpdateUI?: boolean): Action	//Returns an action which removes keyframe at specific time
  createRemoveKeyframeRangeAction(inTime: TickTime, outTime: TickTime, UpdateUI?: boolean): Action	//Returns an action which removes keyframe at specific time range
  createSetValueAction(inKeyFrame: Keyframe, inSafeForPlayback?: boolean): Action	//Creates and returns an action object which can be used to set the value of a non-time varying component
  createAddKeyframeAction(inKeyFrame: Keyframe): Action	//Creates and returns an action object which can be used to add a keyframe component
  createSetTimeVaryingAction(inTimeVarying: boolean): Action	//Creates and returns an action object to set the component to be time varying
  getStartValue(): Promise<Keyframe>	//Returned promise will be fullfilled with the start value (keyframe) of the component param
  getKeyframeListAsTickTimes(): TickTime[]	//Get a list of tickTime for the keyframes of this component param
  getKeyframePtr(time?: TickTime): Keyframe	//Get the Keyframe at the given tickTime postion
  isTimeVarying(): boolean	//Returns true if the parameter value varies over time (for the duration of the item)
  createSetInterpolationAtKeyframeAction(inTime: TickTime, InterpolationMode: number, UpdateUI?: boolean): Action	//Returns an action which sets the interpolation mode of keyframe at the given time
  areKeyframesSupported(): Promise<boolean>	//Returns bool whether keyframes are supported for this component parameter
  displayName: string	//Returns the display name of the component param
}

export declare type CompoundAction = {
  addAction(action: Action): boolean	//Add an action to the compound action
  empty: boolean	//Is the compound action empty?
}

export declare type EncoderManagerStatic = {
  getManager(): EncoderManager	//Get the Encoder Manager object.
  getExportFileExtension(sequence: Sequence, presetFilePath: string): Promise<string>	//Get the Export File Extension of Input Preset file
  EXPORT_QUEUE_TO_AME: string	//Export type used to queue an export job into the Adobe Media Encoder export queue
  EXPORT_QUEUE_TO_APP: string	//Export type used to queue an export job into the app export queue
  EXPORT_IMMEDIATELY: string	//Export type used to immediately exporting an object
  EVENT_RENDER_COMPLETE: string	//Broadcast when AME is finished rendering
  EVENT_RENDER_ERROR: string	//Broadcast when AME gives back error message
  EVENT_RENDER_CANCEL: string	//Broadcast when AME job is canceled
  EVENT_RENDER_QUEUE: string	//Broadcast when AME job is queued
  EVENT_RENDER_PROGRESS: string	//Broadcast when AME job is rendering the job
}

export declare type EncoderManager = {
  exportSequence(sequence: Sequence, exportType: Constants.ExportType, outputFile?: string, presetFile?: string, exportFull?: boolean): Promise<boolean>	//Export a sequence. If no output file and preset is specified, the sequence will be exported with the applied export settings or standard export rules will be applied.
  isAMEInstalled: boolean	//Check if AME is installed.
}

export declare type ExporterStatic = {
  exportSequenceFrame(sequence: Sequence, time: TickTime, filename: string, filepath: string, width: number, height: number): Promise<boolean>	//Exports from a sequence. Supported formats are bmp, dpx, gif, jpg, exr, png, tga and tif
}

export declare type Exporter = {
}

export declare type FolderItemStatic = {
  cast(projectItem: ProjectItem): FolderItem	//Cast ProjectItem in to FolderItem
}

export declare type FolderItem = {
  createBinAction(name: string, makeUnique: boolean): Action	//Returns an action that lets users create a new bin.
  createSmartBinAction(name: string, searchQuery: string): Action	//Creates a smart bin with given name and returns the Folder object
  createRenameBinAction(name: string): Action	//Rename the Bin and return true if it's successful
  getItems(): Promise<ProjectItem[]>	//Collection of child items of this folder.
  createRemoveItemAction(item: ProjectItem): Action	//Creates an action that removes the given item from this folder.
  createMoveItemAction(item: ProjectItem, newParent: FolderItem): Action	//Creates an action that moves the given item to the provided folder item newParent.
  createSetNameAction(inName: string): Action	//Returns action that renames projectItem
  getParent(): Promise<ProjectItem>	//Get the parent project item of this project item.
  getProject(): Promise<Project>	//Get the parent Project of this projectItem.
  name: string	//The name of this project item.
}

export declare type FootageInterpretation = {
  getFrameRate(): number	//Get frame rate of footage
  setFrameRate(frameRate: number): boolean	//Set frame rate of footage
  getPixelAspectRatio(): number	//Get pixel aspect ratio of footage
  setPixelAspectRatio(pixelAspectRatio: number): boolean	//Set pixel aspect ratio of footage
  getFieldType(): number	//Get field type of footage
  setFieldType(fieldType: number): boolean	//Set field type of footage
  getRemovePullDown(): boolean	//Get removePullDown property of footage
  setRemovePullDown(removePulldown: boolean): boolean	//Set removePullDown property of footage
  getAlphaUsage(): number	//Get alpha usage type property of footage
  setAlphaUsage(alphaUsage: number): boolean	//Set alpha usage type property of footage
  getIgnoreAlpha(): boolean	//Get ignore alpha property of footage
  setIgnoreAlpha(ignoreAlpha: boolean): boolean	//Set ignore alpha property of footage
  getInvertAlpha(): boolean	//Get invert alpha property of footage
  setInvertAlpha(invertAlpha: boolean): boolean	//Set invert alpha property of footage
  getVrConform(): number	//Get vr conform projection type of footage
  setVrConform(vrConform: number): boolean	//Set vr conform projection type of footage
  getVrLayout(): number	//Get vr layout type of footage
  setVrLayout(vrLayOut: number): boolean	//Set vr layout type of footage
  getVrHorzView(): number	//Get vr horizontal view of footage
  setVrHorzView(vrHorzView: number): boolean	//Set vr horizontal view of footage
  getVrVertView(): number	//Get vr vertical view of footage
  setVrVertView(vrVertView: number): boolean	//Set vr horizontal view of footage
  getInputLUTID(): string	//Get input LUTID of footage
  setInputLUTID(inputLUTID: string): boolean	//Set input LUTID of footage
  ALPHACHANNEL_NONE: number	//alpha channel none
  ALPHACHANNEL_STRAIGHT: number	//alpha channel straight
  ALPHACHANNEL_PREMULTIPLIED: number	//alpha channel premultiplied
  ALPHACHANNEL_IGNORE: number	//alpha channel ignore
  FIELD_TYPE_DEFAULT: number	//default filed type invalid
  FIELD_TYPE_PROGRESSIVE: number	//field type progressive
  FIELD_TYPE_UPPERFIRST: number	//field type upperfirst
  FIELD_TYPE_LOWERFIRST: number	//field type lowerfirst
}

export declare type FrameRateStatic = {
  createWithValue(value: number): FrameRate	//Create frame rate object with a value
}

export declare type FrameRate = {
  (): FrameRate
  equals(frameRate: FrameRate): boolean	//Returns true if the given FrameRate is equal to this FrameRate object
  ticksPerFrame: number	//Read/Write property to get/set ticks per frame.
  value: number	//Get the number of frames per second.
}

export declare type GuidStatic = {
  fromString(stringValue: string): Guid	//Create a guid from a string
}

export declare type Guid = {
  (): Guid
  toString(): string	//Return string representation of the GUID
}

export declare type IngestSettings = {
  getIsIngestEnabled(): Promise<boolean>	//Get whether or not ingest is enabled
  setIngestEnabled(enabled: boolean): Promise<boolean>	//Set whether or not ingest is enabled
}

export declare type KeyframeStatic = {
  INTERPOLATION_MODE_LINEAR: number	//Linear interpolation mode
  INTERPOLATION_MODE_HOLD: number	//Hold interpolation mode
  INTERPOLATION_MODE_BEZIER: number	//Bezier interpolation mode
  INTERPOLATION_MODE_TIME: number	//Time interpolation mode
  INTERPOLATION_MODE_TIME_TRANSITION_START: number	//Time transition start interpolation mode
  INTERPOLATION_MODE_TIME_TRANSITION_END: number	//Time transition end interpolation mode
}

export declare type Keyframe = {
  getTemporalInterpolationMode(): Promise<number>	//Gets temporal interpolation mode of a keyframe
  setTemporalInterpolationMode(temporalInterpolationMode: number): Promise<boolean>	//Sets temporal interpolation mode of a keyframe
  value: {value: string | number | boolean | Color | PointF}
  position: TickTime	//Get/Set position of a keyframe
}

export declare type MarkerStatic = {
  MARKER_TYPE_COMMENT: string	//Marker Type: Comment
  MARKER_TYPE_CHAPTER: string	//Marker Type: Chapter
  MARKER_TYPE_FLVCUEPOINT: string	//Marker Type: FLVCuePoint
  MARKER_TYPE_WEBLINK: string	//Marker Type: WebLink
}

export declare type Marker = {
  getColor(): Color	//Get color code of the marker.
  getComments(): string	//Get comments of the marker.
  getDuration(): TickTime	//Get duration time of the marker.
  getName(): string	//Get name of the marker.
  getUrl(): string	//Get url of the marker.
  getTarget(): string	//Get target of the marker. Used together with url for web targets.
  getType(): string	//Get type of the marker. e.g. Cue / Track / Subclip / Cart
  getStart(): TickTime	//Get start time of the marker.
  createSetNameAction(name: string): Action	//Return an action to set the name of the marker.
  createSetDurationAction(tickTime: TickTime): Action	//Return an action to set the duration of the marker.
  createSetTypeAction(markerType: string): Action	//Return an action to set the type of the marker.
  createSetCommentsAction(comments: string): Action	//Return an action to set the comments of the marker.
}

export declare type MarkersStatic = {
  getMarkers(markerOwnerObject: Sequence | ProjectItem): Promise<Markers>	//Returns the Markers object for Sequence Or ProjectItem
}

export declare type Markers = {
  getMarkers(filters?: string[]): Marker[]	//Get all markers
  createRemoveMarkerAction(marker: Marker): Action	//Remove the given marker
  createMoveMarkerAction(marker: Marker, tickTime: TickTime): Action	//Move the given marker at new time value
  createAddMarkerAction(Name: string, markerType?: string, startTime?: TickTime, duration?: TickTime, comments?: string): Action	//Add a new marker
}

export declare type Media = {
  createSetStartAction(time: TickTime): Action	//Returns action that set start of media
  start: Promise<TickTime>	//Get the media start time
  duration: Promise<TickTime>	//Get the media duration
}

export declare type MetadataStatic = {
  getProjectMetadata(projectItem: ProjectItem): Promise<string>	//Get project metadata
  getXMPMetadata(projectItem: ProjectItem): Promise<string>	//Get project XMP metadata
  createSetProjectMetadataAction(projectItem: ProjectItem, metadata: string, updatedFields: string[]): Action	//Get set project metadata action
  createSetXMPMetadataAction(projectItem: ProjectItem, metadata: string): Action	//Get set project XMP metadata action
  addPropertyToProjectMetadataSchema(name: string, label: string, type: number): Promise<boolean>	//Add name and label property to project metadata schema
  getProjectColumnsMetadata(projectItem: ProjectItem): Promise<string>	//Get project column metadata from project item
  getProjectPanelMetadata(): Promise<string>	//Get project panel metadata
  setProjectPanelMetadata(metadata: string): Promise<boolean>	//Set project panel metadata
  METADATA_TYPE_INTEGER: number	//Metadata Type: INTEGER
  METADATA_TYPE_REAL: number	//Metadata Type: REAL
  METADATA_TYPE_TEXT: number	//Metadata Type: TEXT
  METADATA_TYPE_BOOLEAN: number	//Metadata Type: BOOLEAN
}

export declare type Metadata = {
}

export declare type OpenProjectOptions = {
  setShowConvertProjectDialog(showConvertProjectDialog: boolean): OpenProjectOptions	//Set whether to show the convert project dialog on project open/close
  setShowLocateFileDialog(showLocateFileDialog: boolean): OpenProjectOptions	//Set whether to show the locate file dialog on project open/close
  setShowWarningDialog(showConvertProjectDialog: boolean): OpenProjectOptions	//Set whether to show the warning file dialog on project open/close
  setAddToMRUList(addToMRUList: boolean): OpenProjectOptions	//Set whether to add to MRU list after project changes
  showConvertProjectDialog: boolean	//Get whether the convert project dialog is shown on project open/close
  showLocateFileDialog: boolean	//Get whether locate file dialog is shown on project open/close
  showWarningDialog: boolean	//Get whether the warning file dialog is shown on project open/close
  addToMRUList: boolean	//Get whether to add project changes to MRU list
}

export declare type OperationCompleteEventStatic = {
  OPERATION_STATE_SUCCESS: number	//Represents the state when an operation completes successfully.
  OPERATION_STATE_CANCELLED: number	//Represents the state when an operation is cancelled.
  OPERATION_STATE_FAILED: number	//Represents the state when an operation is failed.
  EVENT_IMPORT_MEDIA_COMPLETE: string	//Event occurs when a media import operation is complete.
  EVENT_EXPORT_MEDIA_COMPLETE: string	//Event occurs when a media export operation is complete.
  EVENT_EFFECT_DROP_COMPLETE: string	//Event occurs when an effect is dropped on a trackitem
  EVENT_EFFECT_DRAG_OVER: string	//Event occurs when an effect is drag over a trackitem
  EVENT_CLIP_EXTEND_REACHED: string	//Event occurs when a clip reached its maximum extend limit.
  EVENT_GENERATIVE_EXTEND_COMPLETE: string	//Event occurs when a generative extend operation is complete.
}

export declare type OperationCompleteEvent = {
  state: number	//Indicates the outcome of a completed operation: Success, Cancelled, or Failed.
}

export declare type PointF = {
  (x?: number, y?: number): PointF
  distanceTo(point: PointF): number	//Get the distance from one point to another point
  x: number	//Get/Set the x value of a point
  y: number	//Get/Set the y value of a point
}

export declare type PointKeyframe = {
  value: {value: PointF}
  position: TickTime	//Get/Set position of a keyframe
}

export declare type ProjectStatic = {
  createProject(path: string): Promise<Project>	//Create a new project
  open(path: string, openProjectOptions?: OpenProjectOptions): Promise<Project>	//Open a project
  getActiveProject(): Promise<Project>	//Currently active project.
  getProject(projectGuid: Guid): Project	//Get project referenced by given UID
}

export declare type Project = {
  getActiveSequence(): Promise<Sequence>	//Get the active sequence of the project
  setActiveSequence(sequence: Sequence): Promise<boolean>	//Set the active sequence of the project
  createSequence(name: string, presetPath?: string): Promise<Sequence>	//Create a new sequence with the default preset path - Parameter presetPath is deprecated, instead use createSequenceWithPresetPath()
  createSequenceFromMedia(name: string, clipProjectItems?: ClipProjectItem[], targetBin?: ProjectItem): Promise<Sequence>	//Create a new sequence with a given name and medias
  getColorSettings(): Promise<ProjectColorSettings>	//Get project color settings object
  deleteSequence(sequence: Sequence): Promise<boolean>	//Delete a given sequence from the project
  getInsertionBin(): Promise<ProjectItem>	//Get current insertion bin
  openSequence(sequence: Sequence): Promise<boolean>	//Open a sequence and return true if successful.
  importSequences(projectPath: string, sequenceIds?: Guid[]): Promise<boolean>
  importAEComps(aepPath: string, compNames: string[], TargetBin?: ProjectItem): Promise<boolean>
  importAllAEComps(aepPath: string, TargetBin?: ProjectItem): Promise<boolean>
  importFiles(filePaths: string[], suppressUI?: boolean, targetBin?: ProjectItem, asNumberedStills?: boolean): Promise<boolean>	//Import files in root/target bin of the project
  close(closeProjectOptions?: CloseProjectOptions): Promise<boolean>	//Close a project
  save(): Promise<boolean>	//Save the project
  saveAs(path: string): Promise<boolean>	//Save the project at the provided path
  getSequence(guid: Guid): Sequence	//Get sequence by id from the project
  getSequences(): Promise<Sequence[]>	//Get an array of all sequences in this project.
  getRootItem(): Promise<FolderItem>	//The root item of the project which contains all items of the project on the lowest level.
  pauseGrowing(pause: boolean): Promise<boolean>	//Pause growing of files instead swap the files
  executeTransaction(callback: (compoundAction: CompoundAction) => void, undoString?: string): boolean	//Execute undoable transaction by passing compound action
  lockedAccess(callback: () => void): void	//Get a read/upgrade locked access to Project, project state will not change during the execution of callback function. Can call executeTransaction while having locked access.
  guid: Guid	//The unique identifier of the project.
  name: string	//The project name.
  path: string	//The absolute file path to the project file.
}

export declare type ProjectClosedEventStatic = {
  EVENT_CLOSED: string	//Event occurs when project was closed.
}

export declare type ProjectClosedEvent = {
  name: string	//The project name.
  path: string	//The absolute file path to the project file.
  id: string	//The unique identifier of the project.
}

export declare type ProjectColorSettings = {
  getSupportedGraphicsWhiteLuminances(): Promise<number[]>	//Get all the graphics white luminance as array of values
  getGraphicsWhiteLuminance(): Promise<number>	//Get the graphics white luminance value
}

export declare type ProjectEventStatic = {
  EVENT_OPENED: string	//Event occurs when project was opened.
  EVENT_ACTIVATED: string	//Event occurs when the active project has changed
  EVENT_DIRTY: string	//Event occurs when the project dirty state changed.
}

export declare type ProjectEvent = {
  name: string	//The project name.
  path: string	//The absolute file path to the project file.
  id: string	//The unique identifier of the project.
  project: Project	//The project object.
}

export declare type ProjectItemStatic = {
  cast(item: FolderItem | ClipProjectItem): ProjectItem	//Cast FolderItem or ClipProjectItem in to ProjectItem
}

export declare type ProjectItem = {
  createSetNameAction(inName: string): Action	//Returns action that renames projectItem
  getParent(): Promise<ProjectItem>	//Get the parent project item of this project item.
  getProject(): Promise<Project>	//Get the parent Project of this projectItem.
  name: string	//The name of this project item.
}

export declare type ProjectItemSelection = {
  getItems(): Promise<ProjectItem[]>	//Get the project items that is represented by this selection.
}

export declare type ProjectSettingsStatic = {
  createSetScratchDiskSettingsAction(project: Project, scratchDiskSettings: ScratchDiskSettings): Action	//Returns an action which sets ScratchDiskSetting
  getScratchDiskSettings(project: Project): Promise<ScratchDiskSettings>	//Returns project ScratchDiskSettings
  getIngestSettings(project: Project): Promise<IngestSettings>	//Returns project ingest settings
  createSetIngestSettingsAction(project: Project, ingestSettings: IngestSettings): Action	//Returns an action which sets IngestSettings
}

export declare type ProjectSettings = {
}

export declare type ProjectUtilsStatic = {
  getSelection(project: Project): Promise<ProjectItemSelection>	//Get array of selected project items in project view
  getProjectViewIds(): Promise<Guid[]>	//Get array of project view ids
  getProjectFromViewId(guid: Guid): Promise<Project>	//Get project based on input view guid
  getSelectionFromViewId(guid: Guid): Promise<ProjectItemSelection>	//Get array of selected projectItem based on input view guid
}

export declare type ProjectUtils = {
}

export declare type PropertiesStatic = {
  getProperties(propertyOwnerObject: Project | Sequence): Promise<Properties>	//Return Property Owner Object
  PROPERTY_PERSISTENT: number	//Property is persistent in backend and shared across cloud project.
  PROPERTY_NON_PERSISTENT: number	//Property is not persisted and will be cleared when the project closes.
}

export declare type Properties = {
  getValueAsInt(name: string): number	//Get named value as integer number
  getValueAsFloat(name: string): number	//Get named value as float number
  getValueAsBool(name: string): boolean	//Get named value as boolean
  getValue(name: string): string	//Get named value in native string form
  createSetValueAction(name: string, value: boolean | string | number, persistenceFlag: Constants.PropertyType): Action	//Create an action to set a named value through scripting. The parameters are <name, value (number, boolean or string), persistence flag>. This method can fail if e.g. the underlying properties object does not support action based setting of properties.
  hasValue(name: string): boolean	//Check if a named value exists under this name.
  createClearValueAction(name: string): Action	//Create an action to clear the value with the given name. This method can fail if e.g. the underlying properties object does not support action based setting of properties.
}

export declare type RectF = {
  (): RectF
  width: number	//Get/Set the width of a rect
  height: number	//Get/Set the height of a rect
}

export declare type ScratchDiskSettingsStatic = {
  FOLDERTYPE_CAPTURE: string	//Folder Type: CAPTURED
  FOLDERTYPE_VIDEO_CAPTURE: string	//Folder Type: VIDEOCAPTURE
  FOLDERTYPE_AUDIO_CAPTURE: string	//Folder Type: AUDIOCAPTURE
  FOLDERTYPE_VIDEO_PREVIEW: string	//Folder Type: VIDEOPREVIEW
  FOLDERTYPE_AUDIO_PREVIEW: string	//Folder Type: AUDIOPREVIEW
  FOLDERTYPE_AUTO_SAVE: string	//Folder Type: AUTOSAVE
  FOLDERTYPE_CCL_LIBRARIES: string	//Folder Type: CCLLIBRARIES
  FOLDERTYPE_CAPSULE_MEDIA: string	//Folder Type: CAPSULEMEDIA
  FOLDER_SAME_AS_PROJECT: string	//Folder: SAMEASPROJECT
  FOLDER_MY_DOCUMNETS: string	//Folder: MYDOCUMNETS
}

export declare type ScratchDiskSettings = {
  setScratchDiskPath(ScratchDiskType: Constants.ScratchDiskFolderType, ScratchDiskValue: Constants.ScratchDiskFolder): boolean	//Sets project ScratchDisk Path
  getScratchDiskPath(ScratchDiskType: Constants.ScratchDiskFolderType): string	//Gets the scratchDisk location for specific disktype - may return symbolic paths for reserved types like 'MyDocuments'
}

export declare type SequenceStatic = {
}

export declare type Sequence = {
  getSequenceVideoTimeDisplayFormat(): Promise<TimeDisplay>	//Get video time display format of this sequence
  getSequenceAudioTimeDisplayFormat(): Promise<TimeDisplay>	//Get audio time display format of this sequence
  getPlayerPosition(): Promise<TickTime>	//Get the player's current position
  setPlayerPosition(positionTime?: TickTime): Promise<boolean>	//Set the player's current position
  clearSelection(): Promise<boolean>	//Clears TrackItem Selection
  setSelection(trackItemSelection: TrackItemSelection): Promise<boolean>	//Updates sequence selection using the given track item selection.
  getVideoTrackCount(): Promise<number>	//Get video track count from this sequence
  getAudioTrackCount(): Promise<number>	//Get audio track count from this sequence
  getCaptionTrackCount(): Promise<number>	//Get caption track count from this sequence
  getVideoTrack(trackIndex: number): Promise<VideoTrack>	//Get video track from track index
  getAudioTrack(trackIndex: number): Promise<AudioTrack>	//Get audio track from track index
  getCaptionTrack(trackIndex: number): Promise<CaptionTrack>	//Get caption track from track index
  getSettings(): Promise<SequenceSettings>	//Get sequence settings object
  createSetSettingsAction(sequenceSettings: SequenceSettings): Action	//Returns action that set sequence settings
  createCloneAction(): Action	//Creates an action to clone the given sequence
  createSubsequence(ignoreTrackTargeting?: boolean): Promise<Sequence>	//Returns a new sequence, which is a sub-sequence of the existing sequence
  isDoneAnalyzingForVideoEffects(): Promise<boolean>	//Returns whether or not the sequence is done analyzing for video effects
  getZeroPoint(): Promise<TickTime>	//Time representing the zero point of the sequence.
  getEndTime(): Promise<TickTime>	//Time representing the end of the sequence
  getInPoint(): Promise<TickTime>	//Get time representing the inPoint of sequence.
  getOutPoint(): Promise<TickTime>	//Get time representing the inPoint of sequence.
  createSetInPointAction(tickTime: TickTime): Action	//Create SetInPointAction for sequence
  createSetZeroPointAction(tickTime: TickTime): Action	//Create an action to set an InPoint for the sequence
  createSetOutPointAction(tickTime: TickTime): Action	//Create SetOutPointAction for sequence
  getProjectItem(): Promise<ProjectItem>	//Get the associated projectItem of the sequence.
  getSelection(): Promise<TrackItemSelection>	//Returns the current selection group of the sequence.
  getFrameSize(): Promise<RectF>	//Gets the size of the frame
  getTimebase(): Promise<string>	//Gets the time base of sequence
  guid: Guid	//The unique identifier of the sequence.
  name: string	//The sequence name.
}

export declare type SequenceEditorStatic = {
  getEditor(sequenceObject: Sequence): SequenceEditor	//Get Sequence Editor reference for editing the sequence timeline
  getInstalledMogrtPath(): Promise<string>	//Get local directory path to adobe mogrt files
}

export declare type SequenceEditor = {
  createRemoveItemsAction(trackItemSelection: TrackItemSelection, ripple: boolean, mediaType: Constants.MediaType, shiftOverLapping?: boolean): Action	//Create remove action for sequence
  createInsertProjectItemAction(projectItem: ProjectItem, time: TickTime, videoTrackIndex: number, audioTrackIndex: number, limitShift: boolean): Action	//Create insert ProjectItem into Sequence Action
  createOverwriteItemAction(projectItem: ProjectItem, time: TickTime, videoTrackIndex: number, audioTrackIndex: number): Action	//Create overwrite Sequence with ProjectItem Action
  createCloneTrackItemAction(trackItem: VideoClipTrackItem | AudioClipTrackItem, timeOffset: TickTime, videoTrackVerticalOffset: number, audioTrackVerticalOffset: number, alignToVideo: boolean, isInsert: boolean): Action	//Duplicate trackItem using an insert or overwrite edit method to a destination track. Target track and start time of trackItem is determined using an offset value from the original trackItem position.
  insertMogrtFromPath(inMGTPath: string, inTime: TickTime, inVideoTrackIndex: number, inAudioTrackIndex: number): (VideoClipTrackItem | AudioClipTrackItem)[]	//Insert input MGT into sequence with time and index defined
  insertMogrtFromLibrary(inLibraryName: string, inElementName: string, inTime: TickTime, inVideoTrackIndex: number, inAudioTrackIndex: number): (VideoClipTrackItem | AudioClipTrackItem)[]	//Insert input MGT into sequence with time and index defined
}

export declare type SequenceSettingsStatic = {
  PAR_SQUARE: string	//Square Pixels (1.0)
  PAR_DVNTSC: string	//DV NTSC (0.9091)
  PAR_DVNTSCWide: string	//DV NTSC Widescreen 16:9 (1.2121)
  PAR_DVPAL: string	//DV PAL (1.0940)
  PAR_DVPALWide: string	//DV PAL Widescreen 16:9 (1.4587)
  PAR_Anamorphic: string	//Anamorphic 2:1 (2.0)
  PAR_HDAnamorphic1080: string	//HD Anamorphic 1080 (1.333)
  PAR_DVCProHD: string	//DVCPRO HD (1.5)
  VIDEO_FIELDTYPE_PROGRESSIVE: number	//Video field type progressive
  VIDEO_FIELDTYPE_UPPER_FIRST: number	//Video field type upper first
  VIDEO_FIELDTYPE_LOWER_FIRST: number	//Video field type lower first
  VIDEO_DISPLAY_FORMAT_23976: number	//23.976 fps TimeCode
  VIDEO_DISPLAY_FORMAT_25: number	//25 fps TimeCode
  VIDEO_DISPLAY_FORMAT_2997: number	//29.97 fps TimeCode
  VIDEO_DISPLAY_FORMAT_2997_NON_DROP: number	//29.97 fps Non-Drop-Frame TimeCode
  VIDEO_DISPLAY_FORMAT_16mm: number	//Feet+Frame 16mm
  VIDEO_DISPLAY_FORMAT_35mm: number	//Feet+Frame 35mm
  VIDEO_DISPLAY_FORMAT_FRAMES: number	//Frames
  AUDIO_CHANNEL_TYPE_MONO: number	//Audio Channel Type Mono
  AUDIO_CHANNEL_TYPE_STEREO: number	//Audio Channel Type Stereo
  AUDIO_CHANNEL_TYPE_51: number	//Audio Channel Type 5.1
  AUDIO_CHANNEL_TYPE_MULTI: number	//Audio Channel Type Multi
  AUDIO_DISPLAY_FORMAT_SAMPLE_RATE: number	//Audio Display format: Audio Sample Timecode
  AUDIO_DISPLAY_FORMAT_MILISECONDS: number	//Audio Display format miliseconds
}

export declare type SequenceSettings = {
  getMaximumBitDepth(): Promise<boolean>	//Find if maximum bit depth is set
  setMaximumBitDepth(useMaxBitDepth: boolean): Promise<boolean>	//Set maximum bit depth to true/false
  getMaxRenderQuality(): Promise<boolean>	//Find if maximum render quality is set
  setMaxRenderQuality(useMaxRenderQuality: boolean): Promise<boolean>	//Set maximum render quality to true/false
  getAudioChannelCount(): Promise<number>	//Get number of channels in the sequence
  getAudioChannelType(): Promise<number>	//Get Audio channel type of sequence. Could be 0 (Mono), 1 (Stereo), 2 (5.1), or 3 (multichannel)
  getAudioDisplayFormat(): Promise<TimeDisplay>	//Get Audio display format
  setAudioDisplayFormat(audioDisplay: TimeDisplay): Promise<boolean>	//Set audio display format of sequence.
  getAudioSampleRate(): Promise<FrameRate>	//Get audio sample rate
  setAudioSampleRate(inRate: FrameRate): Promise<boolean>	//Set audio sample rate
  getVideoDisplayFormat(): Promise<TimeDisplay>	//Get Video display format
  setVideoDisplayFormat(audioDisplay: TimeDisplay): Promise<boolean>	//Set video display format of sequence
  getVideoFieldType(): Promise<number>	//Get video field type in the sequence
  setVideoFieldType(videoFiledType: number): Promise<boolean>	//Set video field type in sequence
  getVideoFrameRect(): Promise<RectF>	//Get video frame rect in the sequence
  setVideoFrameRect(inVideoFrameRect: RectF): Promise<boolean>	//Set video frame rect in sequence
  getVideoPixelAspectRatio(): Promise<string>	//Get Video display format
  setVideoPixelAspectRatio(inPixelAspectRatio: string): Promise<boolean>	//Set video display format of sequence
  getCompositeInLinearColor(): Promise<boolean>	//Get if composite in linear color is checked
  setCompositeInLinearColor(useCompositeInLinearColor: boolean): Promise<boolean>	//Set if composite in linear color is checked
  getEditingMode(): Promise<string>	//Get editing mode of sequence
  setEditingMode(inEditingModeName: string): Promise<boolean>	//Set editing mode of sequence
  getPreviewFileFormat(): Promise<string>	//Get preview file format of sequence
  setPreviewFileFormat(inPreviewCodec: string): Promise<boolean>	//Set preview file format of sequence
  getPreviewCodec(): Promise<string>	//Get preview codec of sequence
  setPreviewCodec(inPreviewCodec: string): Promise<boolean>	//Set preview codec of sequence
  getPreviewFrameRect(): Promise<RectF>	//Get preview video frame rect in the sequence
  setPreviewFrameRect(inPreviewVideoRect: RectF): Promise<boolean>	//Set preview video frame rect in sequence
}

export declare type SequenceUtilsStatic = {
  performSceneEditDetectionOnSelection(clipOperation: string, trackItemSelection: TrackItemSelection): Promise<boolean>	//Performs cut detection on the sequence selection
  SEQUENCE_OPERATION_APPLYCUT: string	//ApplyCuts
  SEQUENCE_OPERATION_CREATEMARKER: string	//CreateMarkers
  SEQUENCE_OPERATION_CREATESUBCLIP: string	//CreateSubclips
}

export declare type SequenceUtils = {
}

export declare type SnapEventStatic = {
  EVENT_SNAP_TO_KEYFRAME: string	//Event occurs a user scrub on timeline over keyframes when shift key is applied.
  EVENT_SNAP_TO_TRACKITEM: string	//Event occurs a user scrub on timeline and snaps to various track item alignments.
  EVENT_SNAP_TO_GUIDES: string	//Event occurs object is snapped to guildelines when holding the Cmd/Ctrl key.
  EVENT_SNAP_RAZOR_TO_PLAYHEAD: string	//Event occurs when the razor tool hovers over the playhead and snaps into position for a cut.
  EVENT_SNAP_RAZOR_TO_MARKER: string	//Event occurs when the razor tool hovers over the all types of markers and snaps into position for a cut.
}

export declare type SnapEvent = {
}

export declare type SourceMonitorStatic = {
  openFilePath(filePath: string): Promise<boolean>	//Open the item at the specified path and send to the Source Monitor for preview
  openProjectItem(projectItem: ProjectItem): Promise<boolean>	//Open input projectItem on Source Monitor
  closeClip(): Promise<boolean>	//Close clip on Source Monitor
  closeAllClips(): Promise<boolean>	//Close all clips on Source Monitor
  getPosition(): Promise<TickTime>	//Get position of source monitor in time
  play(speed?: number): Promise<boolean>	//Play clip at source monitor with input speed
  getProjectItem(): Promise<ProjectItem>	//Get projectItem at source monitor
}

export declare type SourceMonitor = {
}

export declare type TickTimeStatic = {
  createWithFrameAndFrameRate(frameCount: number, frameRate: FrameRate): TickTime	//Constructs a TickTime object with a frame and a frame rate.
  createWithSeconds(seconds: number): TickTime	//Constructs a TickTime object with seconds.
  createWithTicks(ticks: string): TickTime	//Constructs a TickTime object with ticks as a string.
  TIME_ZERO: TickTime	//Zero Tick Time Constant
  TIME_ONE_SECOND: TickTime	//One Second Tick Time Constant
  TIME_ONE_MINUTE: TickTime	//One Second Tick Time Constant
  TIME_ONE_HOUR: TickTime	//One Hour Tick Time Constant
  TIME_MAX: TickTime	//Max Tick Time Constant
  TIME_MIN: TickTime	//Min Tick Time Constant
  TIME_INVALID: TickTime	//Invalid Tick Time Constant
}

export declare type TickTime = {
  (): TickTime
  equals(tickTime: TickTime): boolean	//Returns true if the given TickTime is equal to the TickTime object
  alignToNearestFrame(frameRate: FrameRate): TickTime	//AlignToNearestFrame will return a TickTime that is aligned to the nearest frame boundary greater than or less than the given time, for a given frame rate by rounding any fractional portion.
  alignToFrame(frameRate: FrameRate): TickTime	//alignToFrame will return a TickTime that is aligned to the nearest frame boundary less than the given time, for a given frame rate by rounding any fractional portion.
  add(tickTime: TickTime): TickTime	//Add another TickTime to this one and return it. This TickTime is not modified.
  subtract(tickTime: TickTime): TickTime	//Subtract another TickTime from this one and return it. This TickTime is not modified.
  multiply(factor: number): TickTime	//Multiply this TickTime with a factor and return it. This TickTime is not modified.
  divide(divisor: number): TickTime	//Divide this TickTime by a divisor and return it. In case of a division by zero, TIME_INVALID is returned. This TickTime is not modified.
  seconds: number	//Get the TickTime in seconds
  ticks: string	//Get the TickTime in ticks as a string
  ticksNumber: number	//Get the TickTime in ticks as a number
}

export declare type TimeDisplay = {
  type: number	//Read/Write property to get/set the time display type numeric code
}

export declare type TrackItemSelectionStatic = {
  createEmptySelection(callback0: (selection: TrackItemSelection) => void): boolean	//Create empty selection
}

export declare type TrackItemSelection = {
  addItem(trackItem: VideoClipTrackItem | AudioClipTrackItem, skipDuplicateCheck?: boolean): boolean	//Add a track item to this selection
  removeItem(trackItem: VideoClipTrackItem | AudioClipTrackItem): boolean	//Remove a track item from this selection
  getTrackItems(): Promise<(VideoClipTrackItem | AudioClipTrackItem)[]>	//return list of trackItems inside of trackItemSelection
}

export declare type TransitionFactoryStatic = {
  createVideoTransition(matchName: string): VideoTransition	//Creates a new video filter component based on the input matchName
  getVideoTransitionMatchNames(): Promise<string[]>	//Return a promise which will be fullfilled with an array of video transition matchnames
}

export declare type TransitionFactory = {
}

export declare type UtilsStatic = {
  isAEInstalled(): Promise<boolean>	//Check if AE is installed.
}

export declare type Utils = {
}

export declare type VideoClipTrackItemStatic = {
  TRACKITEMTYPE_EMPTY: number	//Empty Track Item Type
  TRACKITEMTYPE_CLIP: number	//Clip Track Item Type
  TRACKITEMTYPE_TRANSITION: number	//Transition Track Item Type
  TRACKITEMTYPE_PREVIEW: number	//Previe Track Item Type
  TRACKITEMTYPE_FEEDBACK: number	//Feedback Track Item Type
}

export declare type VideoClipTrackItem = {
  createAddVideoTransitionAction(videoTransition: VideoTransition, addTransitionOptionsProperties?: AddTransitionOptions): Action	//Create add transition action for sequence
  createRemoveVideoTransitionAction(transitionPosition?: Constants.TransitionPosition): Action	//Returns true if trackItem has transition
  getMatchName(): Promise<string>	//Returns the value of internal matchname for this trackItem
  getName(): Promise<string>	//Returns the display name for trackItem
  getIsSelected(): Promise<boolean>	//Returns if trackItem is selected or not
  getSpeed(): Promise<number>	//Returns the value of speed of the trackItem
  isAdjustmentLayer(): Promise<boolean>	//Returns true if the trackitem is an adjustment layer
  isSpeedReversed(): Promise<number>	//Returns true if the trackitem is reversed
  createMoveAction(tickTime: TickTime): Action	//Returns an action that moves the inPoint of the track item to a new time, by shifting it by a number of seconds.
  getInPoint(): Promise<TickTime>	//Returns a TickTime object representing the track item in point relative to the start time of the project item referenced by this track item.
  getOutPoint(): Promise<TickTime>	//Returns a TickTime object representing the track item out point relative to the start time of the project item referenced by this track item.
  createSetInPointAction(tickTime: TickTime): Action	//Create SetInPointAction for setting the track item in point relative to the start time of the project item referenced by this track item
  createSetOutPointAction(tickTime: TickTime): Action	//Create SetOutPointAction for setting the track item out point relative to the start time of the project item referenced by this track item
  getStartTime(): Promise<TickTime>	//Returns a TickTime object representing the starting sequence time of this track item relative to the sequence start time.
  getEndTime(): Promise<TickTime>	//Returns a TickTime object representing the ending sequence time of this track item relative to the sequence start time.
  createSetStartAction(tickTime: TickTime): Action	//Create set start time action for sequence
  createSetEndAction(tickTime: TickTime): Action	//Create set end time action for sequence
  getDuration(): Promise<TickTime>	//Returns timecode representing the duration of this track item relative to the sequence start.
  getType(): Promise<number>	//Index representing the type of this track item.
  isDisabled(): Promise<boolean>	//Returns true if trackitem is muted/disabled
  createSetDisabledAction(disabled: boolean): Action	//Returns an action that enables/disables the trackItem 
  createSetNameAction(inName: string): Action	//Returns an action that renames the trackItem
  getMediaType(): Promise<Guid>	//Returns UUID representing the underlying media type of this track item
  getTrackIndex(): Promise<number>	//Index representing the track index of the track this track item belongs to
  getProjectItem(): Promise<ProjectItem>	//Returns the project item for this track item.
  getComponentChain(): Promise<VideoComponentChain>	//Returns VideoComponentChain
}

export declare type VideoComponentChainStatic = {
}

export declare type VideoComponentChain = {
  createInsertComponentAction(component: Component | VideoFilterComponent, componentInsertionIndex: number): Action	//Creates and returns an insert component action
  createAppendComponentAction(component: Component | VideoFilterComponent): Action	//Creates and returns an append component action
  createRemoveComponentAction(component: Component | VideoFilterComponent): Action	//Creates and returns an remove component action
  getComponentAtIndex(componentIndex: number): Component	//Returns the component at the given index
  getComponentCount(): number	//Gets the number of components in the component chain
}

export declare type VideoFilterComponentStatic = {
}

export declare type VideoFilterComponent = {
}

export declare type VideoFilterFactoryStatic = {
  createComponent(matchName: string): Promise<VideoFilterComponent>	//Creates a new video filter component based on the input matchName
  getMatchNames(): Promise<string[]>	//Returns an array of video filter matchNames
  getDisplayNames(): Promise<string[]>	//Returns an array of video filter display names
}

export declare type VideoFilterFactory = {
}

export declare type VideoTrackStatic = {
  EVENT_TRACK_CHANGED: string	//Event Object for Track changed
  EVENT_TRACK_INFO_CHANGED: string	//Event Object for Track Info Changed
  EVENT_TRACK_LOCK_CHANGED: string	//Event Object for Track Lock Changed
}

export declare type VideoTrack = {
  setMute(mute: boolean): Promise<boolean>	//sets the mute state of the track to muted/unmuted
  getMediaType(): Promise<Guid>	//UUID representing the underlying media type of this track
  getIndex(): Promise<number>	//Index representing the track index of this track within the track group.
  isMuted(): Promise<boolean>	//Get mute state of the track
  getTrackItems(trackItemType: Constants.TrackItemType, includeEmptyTrackItems: boolean): VideoClipTrackItem[]	//Returns array of VideoClipTrackItem from the track item type
  name: string	//Get the name of the track
  id: number	//The ID of the track within the TrackGroup
}

export declare type VideoTransitionStatic = {
  TRANSITIONPOSITION_START: number	//TransitionPosition: START
  TRANSITIONPOSITION_END: number	//TransitionPosition: END
}

export declare type VideoTransition = {
}

export declare type EventManagerStatic = {
  addEventListener(target: Project | Sequence | VideoTrack | AudioTrack | EncoderManager, eventName: string | Constants.SnapEvent | Constants.ProjectEvent | Constants.SequenceEvent | Constants.OperationCompleteEvent, eventHandler: (event?: Object) => void, inCapturePhase?: boolean): void	//add event listener to target object
  removeEventListener(target: Project | Sequence | VideoTrack | AudioTrack | EncoderManager, eventName: string | Constants.SnapEvent | Constants.ProjectEvent | Constants.SequenceEvent | Constants.OperationCompleteEvent, eventHandler: (event?: Object) => void): void	//remove event listener from target object
  addGlobalEventListener(eventName: string | Constants.SnapEvent | Constants.ProjectEvent | Constants.SequenceEvent | Constants.OperationCompleteEvent, eventHandler: (event?: Object) => void, inCapturePhase?: boolean): void	//add global event listener
  removeGlobalEventListener(eventName: string | Constants.SnapEvent | Constants.ProjectEvent | Constants.SequenceEvent | Constants.OperationCompleteEvent, eventHandler: (event?: Object) => void): void	//remove global event listener
}

export declare type EventManager = {
}


export namespace Constants {
	export enum MediaType {
		ANY,
		DATA,
		VIDEO,
		AUDIO
	}

	export enum ContentType {
		ANY,
		SEQUENCE,
		MEDIA
	}

	export enum TransitionPosition {
		START,
		END
	}

	export enum TrackItemType {
		EMPTY,
		CLIP,
		TRANSITION,
		PREVIEW,
		FEEDBACK
	}

	export enum ProjectEvent {
		OPENED,
		CLOSED,
		DIRTY,
		ACTIVATED,
		PROJECT_ITEM_SELECTION_CHANGED
	}

	export enum InterpolationMode {
		BEZIER,
		HOLD,
		LINEAR,
		TIME,
		TIME_TRANSITION_END,
		TIME_TRANSITION_START
	}

	export enum SequenceOperation {
		APPLYCUT,
		CREATEMARKER,
		CREATESUBCLIP
	}

	export enum PropertyType {
		PERSISTENT,
		NON_PERSISTENT
	}

	export enum SequenceEvent {
		ACTIVATED,
		CLOSED,
		SELECTION_CHANGED
	}

	export enum VideoTrackEvent {
		TRACK_CHANGED,
		INFO_CHANGED,
		LOCK_CHANGED
	}

	export enum AudioTrackEvent {
		TRACK_CHANGED,
		INFO_CHANGED,
		LOCK_CHANGED
	}

	export enum EncoderEvent {
		RENDER_COMPLETE,
		RENDER_ERROR,
		RENDER_CANCEL,
		RENDER_QUEUE,
		RENDER_PROGRESS
	}

	export enum ScratchDiskFolderType {
		CAPTURE,
		AUDIO_CAPTURE,
		VIDEO_CAPTURE,
		AUDIO_PREVIEW,
		VIDEO_PREVIEW,
		AUTO_SAVE,
		CCL_LIBRARIES,
		CAPSULE_MEDIA
	}

	export enum ScratchDiskFolder {
		SAME_AS_PROJECT,
		MY_DOCUMENTS
	}

	export enum MetadataType {
		INTEGER,
		REAL,
		TEXT,
		BOOLEAN
	}

	export enum ExportType {
		QUEUE_TO_AME,
		QUEUE_TO_APP,
		IMMEDIATELY
	}

	export enum PreferenceKey {
		AUTO_PEAK_GENERATION,
		IMPORT_WORKSPACE,
		SHOW_QUICKSTART_DIALOG
	}

	export enum SnapEvent {
		KEYFRAME,
		RAZOR_PLAYHEAD,
		RAZOR_MARKER,
		TRACKITEM,
		GUIDES
	}

	export enum OperationCompleteEvent {
		CLIP_EXTEND_REACHED,
		EFFECT_DROP_COMPLETE,
		EXPORT_MEDIA_COMPLETE,
		GENERATIVE_EXTEND_COMPLETE,
		IMPORT_MEDIA_COMPLETE
	}

	export enum OperationCompleteState {
		SUCCESS,
		CANCELLED,
		FAILED
	}

	export enum PixelAspectRatio {
		SQUARE,
		DVNTSC,
		DVNTSCWide,
		DVPAL,
		DVPALWide,
		Anamorphic,
		HDAnamorphic1080,
		DVCProHD
	}

	export enum VideoFieldType {
		PROGRESSIVE,
		UPPER_FIRST,
		LOWER_FIRST
	}

	export enum VideoDisplayFormatType {
		FPS_23_976,
		FPS_25,
		FPS_29_97,
		FPS_29_97_NON_DROP,
		FEET_FRAME_16mm,
		FEET_FRAME_35mm,
		FRAMES
	}

	export enum AudioChannelType {
		MONO,
		STEREO,
		SURROUND_51,
		MULTI
	}

	export enum AudioDisplayFormatType {
		SAMPLE_RATE,
		MILLISECONDS
	}
}

export default premierepro
```
